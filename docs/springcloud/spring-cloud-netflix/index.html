<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="ie=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><link rel=preload as=font href=https://www.springcloud.io/fonts/vendor/jost/jost-v4-latin-regular.woff2 type=font/woff2 crossorigin><link rel=preload as=font href=https://www.springcloud.io/fonts/vendor/jost/jost-v4-latin-700.woff2 type=font/woff2 crossorigin><link rel=stylesheet href=https://www.springcloud.io/main.f61ba0b6506edcc484748b67eeea0f249895b5bd362b0928a3f132e9b2c0b3e512f1defc1cf3ec85bcb0fbad5855c145ce61cbe61136910c72f957c3a6581cff.css integrity="sha512-9hugtlBu3MSEdItn7uoPJJiVtb02Kwkoo/Ey6bLAs+US8d78HPPshbyw+61YVcFFzmHL5hE2kQxy+VfDplgc/w==" crossorigin=anonymous><noscript><style>img.lazyload{display:none}</style></noscript><meta name=keywords content="springcloud官方,springcloud中文文档,springcloud最新文档,springcloud中国"><meta name=robots content="index, follow"><meta name=googlebot content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1"><meta name=bingbot content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1"><title>Spring Cloud Netflix - SpringCloud中文社区</title><meta name=description content="Spring Cloud Netflix通过自动配置和绑定到Spring环境和其他Spring编程模型习语，为Spring Boot应用提供了Netflix OSS集成。通过一些简单的注释，您可以在应用程序中快速启用和配置通用模式，并使用经过实战考验的Netflix组件构建大型分布式系统。提供的模式包括服务发现(Eureka)、断路器(Hystrix)、智能路由(Zuul)和客户端负载均衡(Ribbon)。"><link rel=canonical href=https://www.springcloud.io/docs/springcloud/spring-cloud-netflix/><meta property="og:locale" content="zh-CN"><meta property="og:type" content="article"><meta property="og:title" content="Spring Cloud Netflix"><meta property="og:description" content="Spring Cloud Netflix通过自动配置和绑定到Spring环境和其他Spring编程模型习语，为Spring Boot应用提供了Netflix OSS集成。通过一些简单的注释，您可以在应用程序中快速启用和配置通用模式，并使用经过实战考验的Netflix组件构建大型分布式系统。提供的模式包括服务发现(Eureka)、断路器(Hystrix)、智能路由(Zuul)和客户端负载均衡(Ribbon)。"><meta property="og:url" content="https://www.springcloud.io/docs/springcloud/spring-cloud-netflix/"><meta property="og:site_name" content="SpringCloud中文社区"><meta property="article:published_time" content="2020-11-12T13:26:54+01:00"><meta property="article:modified_time" content="2020-11-12T13:26:54+01:00"><meta property="og:image" content="https://www.springcloud.io/doks.png"><meta property="og:image:alt" content="SpringCloud中文社区"><meta name=twitter:card content="summary_large_image"><meta name=twitter:site content="@getdoks"><meta name=twitter:creator content="@henkverlinde"><meta name=twitter:title content="Spring Cloud Netflix"><meta name=twitter:description content="Spring Cloud Netflix通过自动配置和绑定到Spring环境和其他Spring编程模型习语，为Spring Boot应用提供了Netflix OSS集成。通过一些简单的注释，您可以在应用程序中快速启用和配置通用模式，并使用经过实战考验的Netflix组件构建大型分布式系统。提供的模式包括服务发现(Eureka)、断路器(Hystrix)、智能路由(Zuul)和客户端负载均衡(Ribbon)。"><meta name=twitter:image content="https://www.springcloud.io/doks.png"><meta name=twitter:image:alt content="Spring Cloud Netflix"><script type=application/ld+json>{"@context":"https://schema.org","@graph":[{"@type":"Organization","@id":"https://www.springcloud.io/#/schema/organization/1","name":"Doks","url":"https://www.springcloud.io/","sameAs":["https://twitter.com/kevinblandy","https://github.com/KevinBlandy"],"logo":{"@type":"ImageObject","@id":"https://www.springcloud.io/#/schema/image/1","url":"https://www.springcloud.io/logo-doks.png","width":512,"height":512,"caption":"Doks"},"image":{"@id":"https://www.springcloud.io/#/schema/image/1"}},{"@type":"WebSite","@id":"https://www.springcloud.io/#/schema/website/1","url":"https://www.springcloud.io/","name":"SpringCloud中文社区","description":"SpringCloud中文社区专注于文档汉化，更新，以及行业前沿资讯的发布。","publisher":{"@id":"https://www.springcloud.io/#/schema/organization/1"}},{"@type":"WebPage","@id":"https://www.springcloud.io/docs/springcloud/spring-cloud-netflix/","url":"https://www.springcloud.io/docs/springcloud/spring-cloud-netflix/","name":"Spring Cloud Netflix","description":"Spring Cloud Netflix通过自动配置和绑定到Spring环境和其他Spring编程模型习语，为Spring Boot应用提供了Netflix OSS集成。通过一些简单的注释，您可以在应用程序中快速启用和配置通用模式，并使用经过实战考验的Netflix组件构建大型分布式系统。提供的模式包括服务发现(Eureka)、断路器(Hystrix)、智能路由(Zuul)和客户端负载均衡(Ribbon)。","isPartOf":{"@id":"https://www.springcloud.io/#/schema/website/1"},"about":{"@id":"https://www.springcloud.io/#/schema/organization/1"},"datePublished":"2020-11-12T13:26:54CET","dateModified":"2020-11-12T13:26:54CET","breadcrumb":{"@id":"https://www.springcloud.io/docs/springcloud/spring-cloud-netflix/#/schema/breadcrumb/1"},"primaryImageOfPage":{"@id":"https://www.springcloud.io/docs/springcloud/spring-cloud-netflix/#/schema/image/2"},"inLanguage":"en-US","potentialAction":[{"@type":"ReadAction","target":["https://www.springcloud.io/docs/springcloud/spring-cloud-netflix/"]}]},{"@type":"BreadcrumbList","@id":"https://www.springcloud.io/docs/springcloud/spring-cloud-netflix/#/schema/breadcrumb/1","name":"Breadcrumbs","itemListElement":[{"@type":"ListItem","position":1,"item":{"@type":"WebPage","@id":"https://www.springcloud.io","url":"https://www.springcloud.io","name":"Home"}},{"@type":"ListItem","position":3,"item":{"@type":"WebPage","@id":"https://www.springcloud.io/docs/","url":"https://www.springcloud.io/docs/","name":"Docs"}},{"@type":"ListItem","position":4,"item":{"@type":"WebPage","@id":"https://www.springcloud.io/docs/springcloud/","url":"https://www.springcloud.io/docs/springcloud/","name":"Springcloud"}},{"@type":"ListItem","position":5,"item":{"@id":"https://www.springcloud.io/docs/springcloud/spring-cloud-netflix/"}}]},{"@context":"https://schema.org","@graph":[{"@type":"Article","@id":"https://www.springcloud.io/#/schema/article/1","headline":"Spring Cloud Netflix","description":"Spring Cloud Netflix通过自动配置和绑定到Spring环境和其他Spring编程模型习语，为Spring Boot应用提供了Netflix OSS集成。通过一些简单的注释，您可以在应用程序中快速启用和配置通用模式，并使用经过实战考验的Netflix组件构建大型分布式系统。提供的模式包括服务发现(Eureka)、断路器(Hystrix)、智能路由(Zuul)和客户端负载均衡(Ribbon)。","isPartOf":{"@id":"https://www.springcloud.io/docs/springcloud/spring-cloud-netflix/"},"mainEntityOfPage":{"@id":"https://www.springcloud.io/docs/springcloud/spring-cloud-netflix/"},"datePublished":"2020-11-12T13:26:54CET","dateModified":"2020-11-12T13:26:54CET","author":{"@id":"https://www.springcloud.io/#/schema/person/2"},"publisher":{"@id":"https://www.springcloud.io/#/schema/organization/1"},"image":{"@id":"https://www.springcloud.io/docs/springcloud/spring-cloud-netflix/#/schema/image/2"}}]},{"@context":"https://schema.org","@graph":[{"@type":"Person","@id":"https://www.springcloud.io/#/schema/person/2","name":"kevinblandy","sameAs":["https://twitter.com/kevinblandy","https://github.com/KevinBlandy"]}]},{"@context":"https://schema.org","@graph":[{"@type":"ImageObject","@id":"https://www.springcloud.io/docs/springcloud/spring-cloud-netflix/#/schema/image/2","url":"https://www.springcloud.io/doks.png","contentUrl":"https://www.springcloud.io/doks.png","caption":"Spring Cloud Netflix"}]}]}</script><meta name=theme-color content="#fff"><link rel=apple-touch-icon sizes=180x180 href=https://www.springcloud.io/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=https://www.springcloud.io/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=https://www.springcloud.io/favicon-16x16.png><link rel=manifest crossorigin=use-credentials href=https://www.springcloud.io/site.webmanifest><script>var _hmt=_hmt||[];(function(){var a=document.createElement("script"),b;a.src="https://hm.baidu.com/hm.js?d725343fdb7604c5bd89b377295901df",b=document.getElementsByTagName("script")[0],b.parentNode.insertBefore(a,b)})()</script></head><body class="docs single"><div class="header-bar fixed-top"></div><header class="navbar fixed-top navbar-expand-md navbar-light"><div class=container><input class="menu-btn order-0" type=checkbox id=menu-btn>
<label class="menu-icon d-md-none" for=menu-btn><span class=navicon></span></label><a class="navbar-brand order-1 order-md-0 me-auto" href=https://www.springcloud.io/>SpringCloud中文社区</a>
<button id=mode class="btn btn-link order-2 order-md-4" type=button aria-label="Toggle mode">
<span class=toggle-dark><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-moon"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg></span><span class=toggle-light><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-sun"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></span></button><ul class="navbar-nav social-nav order-3 order-md-5"></ul><div class="collapse navbar-collapse order-4 order-md-1"><ul class="navbar-nav main-nav me-auto order-5 order-md-2"><li class=nav-item><a class=nav-link href=https://www.springcloud.io/docs/>中文文档</a></li><li class=nav-item><a class=nav-link href=https://www.springcloud.io/blog/>行业资讯</a></li></ul><div class="break order-6 d-md-none"></div><form class="navbar-form flex-grow-1 order-7 order-md-3"><input id=userinput class="form-control is-search" type=search placeholder="Search docs..." aria-label="Search docs..." autocomplete=off><div id=suggestions class="shadow bg-white rounded"></div></form></div></div></header><div class="wrap container" role=document><div class=content><div class="row flex-xl-nowrap"><div class="col-lg-5 col-xl-4 docs-sidebar"><nav class=docs-links aria-label="Main navigation"><ul class="list-unstyled collapsible-sidebar"><li class=mb-1><button class="btn btn-toggle align-items-center rounded collapsed" data-bs-toggle=collapse data-bs-target=#section-SpringBoot aria-expanded=false>
SpringBoot</button></li><li class=mb-1><button class="btn btn-toggle align-items-center rounded collapsed" data-bs-toggle=collapse data-bs-target=#section-SpringCloud aria-expanded=true>
SpringCloud</button><div class="collapse show" id=section-SpringCloud><ul class="btn-toggle-nav list-unstyled fw-normal pb-1 small"><li><a class="docs-link rounded" href=https://www.springcloud.io/docs/springcloud/spring-cloud-alibaba/>Spring Cloud Alibaba</a></li><li><a class="docs-link rounded" href=https://www.springcloud.io/docs/springcloud/spring-cloud-bus/>Spring Cloud Bus</a></li><li><a class="docs-link rounded" href=https://www.springcloud.io/docs/springcloud/spring-cloud-circuit-breaker/>Spring Cloud Circuit Breaker</a></li><li><a class="docs-link rounded" href=https://www.springcloud.io/docs/springcloud/spring-cloud-consul/>Spring Cloud Consul</a></li><li><a class="docs-link rounded" href=https://www.springcloud.io/docs/springcloud/spring-cloud-gateway/>Spring Cloud Gateway</a></li><li><a class="docs-link rounded" href=https://www.springcloud.io/docs/springcloud/spring-cloud-kubernetes/>Spring Cloud Kubernetes</a></li><li><a class="docs-link rounded active" href=https://www.springcloud.io/docs/springcloud/spring-cloud-netflix/>Spring Cloud Netflix</a></li></ul></div></li></ul></nav></div><nav class="docs-toc d-none d-xl-block col-xl-3" aria-label="Secondary navigation"><div class=page-links><h3>On this page</h3><nav id=TableOfContents><ul><li><a href=#1-服务发现eureka客户端>1 服务发现：Eureka客户端</a><ul><li><a href=#11-如何引入eureka客户端>1.1 如何引入Eureka客户端</a></li><li><a href=#12-向eureka注册服务>1.2 向Eureka注册服务</a></li><li><a href=#13-在eureka服务端上验证>1.3 在Eureka服务端上验证</a></li><li><a href=#14-状态页和健康指示器>1.4 状态页和健康指示器</a></li><li><a href=#15-注册安全的应用程序>1.5 注册安全的应用程序</a></li><li><a href=#16-eureka的健康检查>1.6 Eureka的健康检查</a></li><li><a href=#17-eureka客户端和实例的元数据>1.7 Eureka客户端和实例的元数据</a></li><li><a href=#172-在aws上使用eureka>1.7.2 在AWS上使用Eureka</a></li><li><a href=#173-修改eureka的实例id>1.7.3 修改Eureka的实例ID</a></li><li><a href=#18-使用eurekaclient>1.8 使用EurekaClient</a></li><li><a href=#19-替代原生netflix-eurakaclient>1.9 替代原生Netflix EurakaClient</a></li><li><a href=#110-为什么注册服务如此缓慢>1.10 为什么注册服务如此缓慢</a></li><li><a href=#111-zones>1.11 Zones</a></li><li><a href=#112-刷新eureka客户端>1.12 刷新Eureka客户端</a></li><li><a href=#113-使用springcloud负载均衡的eureka>1.13 使用SpringCloud负载均衡的Eureka</a></li></ul></li><li><a href=#2-服务发现eureka服务端>2 服务发现：Eureka服务端</a><ul><li><a href=#21-如何包含eureka服务端>2.1 如何包含Eureka服务端</a></li><li><a href=#22-如何运行eureka服务端>2.2 如何运行Eureka服务端</a></li><li><a href=#23-高可用区域和地区>2.3 高可用，区域和地区</a></li><li><a href=#24-独立模式>2.4 独立模式</a></li><li><a href=#25-对等模式>2.5 对等模式</a></li><li><a href=#26-何时选择ip地址>2.6 何时选择IP地址</a></li><li><a href=#27-保护eureka服务器>2.7 保护Eureka服务器</a></li><li><a href=#28-jdk11支持>2.8 JDK11支持</a></li></ul></li><li><a href=#3-配置属性>3 配置属性</a></li></ul></nav></div></nav><main class="docs-content col-lg-11 col-xl-9"><nav aria-label=breadcrumb><ol class=breadcrumb><li class=breadcrumb-item><a href=https://www.springcloud.io/>Home</a></li><li class=breadcrumb-item><a href=https://www.springcloud.io/docs/>Docs</a></li><li class=breadcrumb-item><a href=https://www.springcloud.io/docs/springcloud/>SpringCloud</a></li><li class="breadcrumb-item active" aria-current=page>Spring Cloud Netflix</li></ol></nav><h1>Spring Cloud Netflix</h1><p class=lead></p><ul><li>当前版本：3.0.3</li><li>修改时间：2021年7月22日</li><li>官方文档：<a href=https://docs.spring.io/spring-cloud-netflix/docs/current/reference/html/>https://docs.spring.io/spring-cloud-netflix/docs/current/reference/html/</a></li><li>源码仓库：<a href=https://github.com/spring-cloud/spring-cloud-netflix>https://github.com/spring-cloud/spring-cloud-netflix</a></li></ul><p>Spring Cloud Netflix通过自动配置和绑定到Spring环境和其他Spring编程模型习语，为Spring Boot应用提供了Netflix OSS集成。通过一些简单的注释，您可以在应用程序中快速启用和配置通用模式，并使用经过实战考验的Netflix组件构建大型分布式系统。提供的模式包括服务发现(Eureka)、断路器(Hystrix)、智能路由(Zuul)和客户端负载均衡(Ribbon)。</p><h2 id=1-服务发现eureka客户端>1 服务发现：Eureka客户端<a href=#1-服务发现eureka客户端 class=anchor aria-hidden=true>#</a></h2><p>服务发现是基于微服务的体系结构的关键原则之一。尝试手动配置每个客户端或某种形式的约定可能很困难，而且可能易挂。Netflix的服务发现器和客户端Eureka，可以将服务器配置和部署为高可用性，每个服务器都可以将已注册服务的状态复制给其他服务器。</p><h3 id=11-如何引入eureka客户端>1.1 如何引入Eureka客户端<a href=#11-如何引入eureka客户端 class=anchor aria-hidden=true>#</a></h3><p>要在项目中包含Eureaka Client，请使用start中gruop ID为<code>org.springframework.cloud</code>和artifact ID为<code>spring-cloud-starter-netflix-eureka-client</code>的包，有关使用Spring cloud设置构建系统的详细信息，请参阅<a href=https://spring.io/projects/spring-cloud>Spring Cloud Project</a>
页面。</p><h3 id=12-向eureka注册服务>1.2 向Eureka注册服务<a href=#12-向eureka注册服务 class=anchor aria-hidden=true>#</a></h3><p>当客户端向Eureka注册时，它会提供关于自身的元数据，例如主机、端口、健康状态URl、主页和其他详细信息。Eureka接收来自属于某个服务的每个实例的心跳消息。如果在可配置的时间内检测心跳失败，实例客户端通常会从注册中心删除。</p><p>下面的例子展示了一个最小的Eureka客户端应用程序:</p><div class=highlight><pre class=chroma><code class=language-java data-lang=java><span class=nd>@SpringBootApplication</span>
<span class=nd>@RestController</span>
<span class=kd>public</span> <span class=kd>class</span> <span class=nc>Application</span> <span class=o>{</span>

    <span class=nd>@RequestMapping</span><span class=o>(</span><span class=s>&#34;/&#34;</span><span class=o>)</span>
    <span class=kd>public</span> <span class=n>String</span> <span class=nf>home</span><span class=o>()</span> <span class=o>{</span>
        <span class=k>return</span> <span class=s>&#34;Hello world&#34;</span><span class=o>;</span>
    <span class=o>}</span>

    <span class=kd>public</span> <span class=kd>static</span> <span class=kt>void</span> <span class=nf>main</span><span class=o>(</span><span class=n>String</span><span class=o>[]</span> <span class=n>args</span><span class=o>)</span> <span class=o>{</span>
        <span class=k>new</span> <span class=n>SpringApplicationBuilder</span><span class=o>(</span><span class=n>Application</span><span class=o>.</span><span class=na>class</span><span class=o>).</span><span class=na>web</span><span class=o>(</span><span class=kc>true</span><span class=o>).</span><span class=na>run</span><span class=o>(</span><span class=n>args</span><span class=o>);</span>
    <span class=o>}</span>

<span class=o>}</span>
</code></pre></div><p>注意，上面的示例只是一个普通的Spring Boot应用程序。通过包管理文件引入<code>spring-cloud-starter-netflix-Eureka-client</code>依赖，你的应用程序将自动注册到Eureka Server。定位 Eureka服务器需要配置，如下面的例子所示:</p><p><strong>application.yml</strong></p><div class=highlight><pre class=chroma><code class=language-yml data-lang=yml><span class=nt>eureka</span><span class=p>:</span><span class=w>
</span><span class=w>  </span><span class=nt>client</span><span class=p>:</span><span class=w>
</span><span class=w>    </span><span class=nt>serviceUrl</span><span class=p>:</span><span class=w>
</span><span class=w>      </span><span class=nt>defaultZone</span><span class=p>:</span><span class=w> </span><span class=l>http://localhost:8761/eureka/</span><span class=w>
</span></code></pre></div><p>在前面的示例中，<code>defaultZone</code> 是一个缺省字符串回调值，它为任何不填写注册中心地址的客户端提供一个默认值。(换句话说：不填此项，eureka使用http://localhost:8761/eureka/作为默认地址)</p><blockquote><p>📍 这个<code>defaultZone</code>属性是区分大小写的，并且需要驼峰命令法，因为<code>serviceUrl</code>属性是<code>Map&lt;String, String></code>。因此，<code>defaultZone</code>属性不遵循常规Spring Boot蛇形命名法约定。</p></blockquote><p>默认的应用程序名称(即服务 ID)、虚拟主机和非安全端口(取自环境)分别为<code>${ spring.application.name }</code>、<code>${ spring.application.name }</code>和<code>${ server.port }</code>。</p><p>在包管理工具中引入<code>spring-cloud-starter-netflix-Eureka-client</code>,使得应用程序既成为Eureka示例，也成为客户端（它可以查询注册中心定位其他服务）。实例行为是由<code>euraka.instance.*</code>配置驱动的，但是你要确保你的应用程序配置<code>spring.application.name</code>值。</p><blockquote><p>有关可配置选项的更多详细信息，请参阅<a href=https://github.com/spring-cloud/spring-cloud-netflix/tree/main/spring-cloud-netflix-eureka-client/src/main/java/org/springframework/cloud/netflix/eureka/EurekaInstanceConfigBean.java>EurekaInstanceConfigBean</a>和<a href=https://github.com/spring-cloud/spring-cloud-netflix/tree/main/spring-cloud-netflix-eureka-client/src/main/java/org/springframework/cloud/netflix/eureka/EurekaClientConfigBean.java>EurekaClientConfigBean</a>。</p></blockquote><p>要禁用Eureka发现客户端，你可以将<code>Eureka.Client.enabled</code>设置为<code>false</code>。当 <code>spring.cloud.Discovery.enabled</code>设置为<code>false</code>时，Eureka发现客户端也将被禁用。</p><h3 id=13-在eureka服务端上验证>1.3 在Eureka服务端上验证<a href=#13-在eureka服务端上验证 class=anchor aria-hidden=true>#</a></h3><p>如果<code>eureka.client.serviceur.defaultzone</code>的Url中嵌入了凭据(curl样式的，示例：user: password@localhost: 8761/eureka)，HTTP的基本身份验证将自动添加到Eureka客户机中。对于更负载的需求，你可以创建类型为：<code>DiscoveryClientOptionalArgs</code> 的<code>@bean</code>，并将<code>ClientFilter</code>实例插入其中，所有这些都应用于从客户机到服务器的调用。</p><p>当Eureka服务器需要客户端证书进行身份验证时，客户端证书和信任存储可以通过属性进行配置，如下例所示:</p><p><strong>application.yml</strong></p><div class=highlight><pre class=chroma><code class=language-yml data-lang=yml><span class=nt>eureka</span><span class=p>:</span><span class=w>
</span><span class=w>  </span><span class=nt>client</span><span class=p>:</span><span class=w>
</span><span class=w>    </span><span class=nt>tls</span><span class=p>:</span><span class=w>
</span><span class=w>      </span><span class=nt>enabled</span><span class=p>:</span><span class=w> </span><span class=kc>true</span><span class=w>
</span><span class=w>      </span><span class=nt>key-store</span><span class=p>:</span><span class=w> </span><span class=l>&lt;path-of-key-store&gt;</span><span class=w>
</span><span class=w>      </span><span class=nt>key-store-type</span><span class=p>:</span><span class=w> </span><span class=l>PKCS12</span><span class=w>
</span><span class=w>      </span><span class=nt>key-store-password</span><span class=p>:</span><span class=w> </span><span class=l>&lt;key-store-password&gt;</span><span class=w>
</span><span class=w>      </span><span class=nt>key-password</span><span class=p>:</span><span class=w> </span><span class=l>&lt;key-password&gt;</span><span class=w>
</span><span class=w>      </span><span class=nt>trust-store</span><span class=p>:</span><span class=w> </span><span class=l>&lt;path-of-trust-store&gt;</span><span class=w>
</span><span class=w>      </span><span class=nt>trust-store-type</span><span class=p>:</span><span class=w> </span><span class=l>PKCS12</span><span class=w>
</span><span class=w>      </span><span class=nt>trust-store-password</span><span class=p>:</span><span class=w> </span><span class=l>&lt;trust-store-password&gt;</span><span class=w>
</span></code></pre></div><p>启用<code>Eureka.client.TLS.enabled </code>要为true才能启用Eureka客户端的TLS。当省略<code>eurea.client.tls.trust-store</code>时，将使用JVM默认信任存储。<code>Eureka.client.tls.key-store-type</code>和<code>eureka.client.tls.trust-store-type</code>的默认值是 PKCS12。如果省略密码属性，则假定为空密码。</p><blockquote><p>由于 Eureka 中的限制，不可能支持每个服务器的基本授权凭证，因此只使用找到的第一组凭证。</p></blockquote><p>如果你想定制Eureka HTTP客户端使用的<code>RestTemplate</code>，你可以创建一个 <code>EurekaClientHttpRequestFactorySupplier</code>，并编写自己的逻辑来生成<code>ClientHttpRequestFactory</code>实例。</p><h3 id=14-状态页和健康指示器>1.4 状态页和健康指示器<a href=#14-状态页和健康指示器 class=anchor aria-hidden=true>#</a></h3><p>Eureka 实例的状态页面和健康状态指示器分别默认为<code>/info</code> 和<code>/health</code>，这是Spring Boot Actuator应用程序中有用的端点默认位置。如果使用非默认的上下文路径或servlet路径(比如 server.servletPath =/custom) ，那么即使对于实现的应用程序也需要修改这些路径。下面的示例显示了这两个设置的默认值:</p><p><strong>application.yml</strong></p><div class=highlight><pre class=chroma><code class=language-yml data-lang=yml><span class=nt>eureka</span><span class=p>:</span><span class=w>
</span><span class=w>  </span><span class=nt>instance</span><span class=p>:</span><span class=w>
</span><span class=w>    </span><span class=nt>statusPageUrlPath</span><span class=p>:</span><span class=w> </span><span class=l>${server.servletPath}/info</span><span class=w>
</span><span class=w>    </span><span class=nt>healthCheckUrlPath</span><span class=p>:</span><span class=w> </span><span class=l>${server.servletPath}/health</span><span class=w>
</span></code></pre></div><p>这些链接显示在客户端使用的元数据中，并且在某些场景中用于决定是否向应用程序发送请求，因此如果这些请求是准确的，就很有帮助。</p><blockquote><p>在Dalston(版本名字)中，当更改管理上下文路径时，还需要设置状态和运行状况检查url。这个要求从Edgware开始就被删除了</p></blockquote><h3 id=15-注册安全的应用程序>1.5 注册安全的应用程序<a href=#15-注册安全的应用程序 class=anchor aria-hidden=true>#</a></h3><p>如果你的应用程序希望通过 HTTPS 进行联系，可以在EurekaInstanceConfigBean 中设置两个属性:</p><ul><li><code>Eureka.instance.[nonsecurtenabled]=[false]</code></li><li><code>Eureka.instance.[securePortEnabled]=[true]</code></li></ul><p>这样做使Eureka发布的实例信息显示了对安全通信的明确偏好。Spring Cloud <code>DiscoveryClient</code> 总是返回一个以 https开头的 URI，用于以这种方式配置的服务。类似地，当以这种方式配置服务时，Eureka (本机)实例信息具有一个安全的健康检查 URL。</p><p>由于Eureka内部的工作方式，它仍然为状态和主页发布一个不安全的URL，除非你也显式地覆盖这些内容。你可以使用占位符来配置eureka实例 url，如下面的例子所示:</p><p><strong>application.yml</strong></p><div class=highlight><pre class=chroma><code class=language-yml data-lang=yml><span class=nt>eureka</span><span class=p>:</span><span class=w>
</span><span class=w>  </span><span class=nt>instance</span><span class=p>:</span><span class=w>
</span><span class=w>    </span><span class=nt>statusPageUrl</span><span class=p>:</span><span class=w> </span><span class=l>https://${eureka.hostname}/info</span><span class=w>
</span><span class=w>    </span><span class=nt>healthCheckUrl</span><span class=p>:</span><span class=w> </span><span class=l>https://${eureka.hostname}/health</span><span class=w>
</span><span class=w>    </span><span class=nt>homePageUrl</span><span class=p>:</span><span class=w> </span><span class=l>https://${eureka.hostname}/</span><span class=w>
</span></code></pre></div><p>(注意 <code>${Eureka.hostname}</code>是一个本机占位符，只能在 Eureka 的后续版本中使用。对于Spring占位符也可以实现同样的功能ーー例如，使用 <code>${eureka.instance.hostname}</code>.)</p><blockquote><p>如果你的应用程序运行在代理之后，并且SSL终止在代理中(例如，如果你作为服务运行在Cloud Foundry或其他平台上) ，然后，你需要确保“转发”的代理头被应用程序拦截和处理。如果在Spring Boot应用程序中嵌入的Tomcat容器对&rsquo;X-Forwarded-* &lsquo;头有显式配置，这将自动生效。应用程序呈现给自身的链接是错误的(错误的主机、端口或协议)，这是配置错误的标志。</p></blockquote><h3 id=16-eureka的健康检查>1.6 Eureka的健康检查<a href=#16-eureka的健康检查 class=anchor aria-hidden=true>#</a></h3><p>默认情况下，Eureka使用客户端心跳来确定客户端是否启动。除非另行指定，否则发现客户端不会根据Spring Boot执行器传播应用程序的当前运行状况检查状态。因此，在成功注册后，Eureka总是宣布应用程序处于<code>UP</code>状态。可以通过启用Eureka运行状况检查来更改此行为，这将导致将应用程序状态传播到Eureka。因此，每个其他应用程序不会向处于<code>UP</code>状态以外的应用程序发送流量。下面的示例显示如何为客户端启用运行状况检查。</p><p><strong>application.yml</strong></p><div class=highlight><pre class=chroma><code class=language-yml data-lang=yml><span class=nt>eureka</span><span class=p>:</span><span class=w>
</span><span class=w>  </span><span class=nt>client</span><span class=p>:</span><span class=w>
</span><span class=w>    </span><span class=nt>healthcheck</span><span class=p>:</span><span class=w>
</span><span class=w>      </span><span class=nt>enabled</span><span class=p>:</span><span class=w> </span><span class=kc>true</span><span class=w>
</span></code></pre></div><blockquote><p><code>eureka.client.healthcheck.enabled=true</code>应该只在<code>application.yml</code>中设置。在<code>bootstrap.yml</code>中设置这个值会引起不好的副作用。例如在Eureka以<code>UNKNOWN</code>状态注册。</p></blockquote><p>如果你需要对运行状况检查进行更多的控制，可以考虑实现自己的检查<code>com.netflix.appinfo.HealthCheckHandler</code>。</p><h3 id=17-eureka客户端和实例的元数据>1.7 Eureka客户端和实例的元数据<a href=#17-eureka客户端和实例的元数据 class=anchor aria-hidden=true>#</a></h3><p>花点时间了解Eureka元数据是如何工作的是值得的，这样您就可以在您的平台上以一种有意义的方式使用它。对于主机名、IP地址、端口号、状态页和健康检查等信息，有标准的元数据。这些信息发布在服务注册中心中，客户端使用它们以一种简单的方式联系服务。附加的元数据可以添加到实例注册的<code>eureka.instance.metadataMap</code>中，该元数据可以在远程客户机中访问。一般来说，附加的元数据不会改变客户机的行为，除非客户机知道元数据的含义。在一些特殊情况下，Spring Cloud已经为元数据映射赋予了意义，本文稍后将对此进行描述。</p><h4 id=171-在cloud-foundry上使用eureka>1.7.1 在Cloud Foundry上使用Eureka<a href=#171-在cloud-foundry上使用eureka class=anchor aria-hidden=true>#</a></h4><p>Cloud Foundry有一个全局路由器，这样同一个应用的所有实例都有相同的主机名(其他具有类似架构的PaaS解决方案也有相同的安排)。这并不一定是使用Eureka的障碍。但是，如果你使用路由器(建议或强制使用，这取决于平台的设置方式)，则需要显式设置主机名和端口号(安全或不安全)，以便它们使用路由器。你可能还希望使用实例元数据，以便能够区分客户机上的实例(例如，在自定义负载平衡器中)。默认情况下，<code>eureka.instance.instanceId</code>是<code>vcap.application.Instance_id</code>，示例如下:</p><p><strong>application.yml</strong></p><div class=highlight><pre class=chroma><code class=language-yml data-lang=yml><span class=nt>eureka</span><span class=p>:</span><span class=w>
</span><span class=w>  </span><span class=nt>instance</span><span class=p>:</span><span class=w>
</span><span class=w>    </span><span class=nt>hostname</span><span class=p>:</span><span class=w> </span><span class=l>${vcap.application.uris[0]}</span><span class=w>
</span><span class=w>    </span><span class=nt>nonSecurePort</span><span class=p>:</span><span class=w> </span><span class=m>80</span><span class=w>
</span></code></pre></div><p>根据在Cloud Foundry实例中设置安全规则的方式，您能够注册并使用主机VM的IP地址来进行直接的服务到服务调用。这个特性在关键的Web服务(PWS)上还不可用。</p><h3 id=172-在aws上使用eureka>1.7.2 在AWS上使用Eureka<a href=#172-在aws上使用eureka class=anchor aria-hidden=true>#</a></h3><p>如果计划将应用部署到AWS云，则必须将Eureka实例配置为AWS感知。你可以通过如下方式定制<code>EurekaInstanceConfigBean</code>:</p><div class=highlight><pre class=chroma><code class=language-java data-lang=java><span class=nd>@Bean</span>
<span class=nd>@Profile</span><span class=o>(</span><span class=s>&#34;!default&#34;</span><span class=o>)</span>
<span class=kd>public</span> <span class=n>EurekaInstanceConfigBean</span> <span class=nf>eurekaInstanceConfig</span><span class=o>(</span><span class=n>InetUtils</span> <span class=n>inetUtils</span><span class=o>)</span> <span class=o>{</span>
  <span class=n>EurekaInstanceConfigBean</span> <span class=n>bean</span> <span class=o>=</span> <span class=k>new</span> <span class=n>EurekaInstanceConfigBean</span><span class=o>(</span><span class=n>inetUtils</span><span class=o>);</span>
  <span class=n>AmazonInfo</span> <span class=n>info</span> <span class=o>=</span> <span class=n>AmazonInfo</span><span class=o>.</span><span class=na>Builder</span><span class=o>.</span><span class=na>newBuilder</span><span class=o>().</span><span class=na>autoBuild</span><span class=o>(</span><span class=s>&#34;eureka&#34;</span><span class=o>);</span>
  <span class=n>bean</span><span class=o>.</span><span class=na>setDataCenterInfo</span><span class=o>(</span><span class=n>info</span><span class=o>);</span>
  <span class=k>return</span> <span class=n>bean</span><span class=o>;</span>
<span class=o>}</span>
</code></pre></div><h3 id=173-修改eureka的实例id>1.7.3 修改Eureka的实例ID<a href=#173-修改eureka的实例id class=anchor aria-hidden=true>#</a></h3><p>一个普通的Netflix Eureka实例是用一个与它的主机名相等的ID注册的(也就是说，每个主机只有一个服务)。Spring Cloud Eureka提供了一个合理的默认值，定义如下:
<code>${spring.cloud.client.hostname}:${spring.application.name}:${spring.application.instance_id:${server.port}}</code></p><p>一个例子是：<code>myhost:myappname:8080</code>。
通过使用Spring Cloud，您可以通过在<code>eureka.instance.instanceId</code>中提供唯一的标识符来覆盖这个值。，如下例所示:</p><p><strong>application.yml</strong></p><div class=highlight><pre class=chroma><code class=language-yml data-lang=yml><span class=nt>eureka</span><span class=p>:</span><span class=w>
</span><span class=w>  </span><span class=nt>instance</span><span class=p>:</span><span class=w>
</span><span class=w>    </span><span class=nt>instanceId</span><span class=p>:</span><span class=w> </span><span class=l>${spring.application.name}:${vcap.application.instance_id:${spring.application.instance_id:${random.value}}}</span><span class=w>
</span></code></pre></div><p>使用前面示例中显示的元数据和部署在localhost上的多个服务实例，将插入随机值以使实例唯一。在Cloud Foundry中，<code>vcap.application.instance_id</code>是在Spring Boot应用程序中自动填充的，因此不需要这个随机值。</p><h3 id=18-使用eurekaclient>1.8 使用EurekaClient<a href=#18-使用eurekaclient class=anchor aria-hidden=true>#</a></h3><p>一旦你拥有了一个作为发现客户端的应用程序，您就可以使用它从<code>Eureka Server</code>发现服务实例。一种方法是使用本机<code>com.netflix.discovery.EurekaClient</code>(与Spring Cloud DiscoveryClient相反)，如下面的示例所示。</p><div class=highlight><pre class=chroma><code class=language-java data-lang=java><span class=nd>@Autowired</span>
<span class=kd>private</span> <span class=n>EurekaClient</span> <span class=n>discoveryClient</span><span class=o>;</span>

<span class=kd>public</span> <span class=n>String</span> <span class=nf>serviceUrl</span><span class=o>()</span> <span class=o>{</span>
    <span class=n>InstanceInfo</span> <span class=n>instance</span> <span class=o>=</span> <span class=n>discoveryClient</span><span class=o>.</span><span class=na>getNextServerFromEureka</span><span class=o>(</span><span class=s>&#34;STORES&#34;</span><span class=o>,</span> <span class=kc>false</span><span class=o>);</span>
    <span class=k>return</span> <span class=n>instance</span><span class=o>.</span><span class=na>getHomePageUrl</span><span class=o>();</span>
<span class=o>}</span>
</code></pre></div><blockquote><p>不要在<code>@PostConstruct</code>方法或<code>@Scheduled</code>方法中使用<code>eurekclient</code>(或在<code>ApplicationContext</code>可能还没有启动的任何地方)。它是在<code>SmartLifecycle</code>中初始化的(<code>phase=0</code>)，所以你最早可以依赖它是在另一个具有更高阶段的<code>SmartLifecycle</code>中。</p></blockquote><h4 id=181-eurekacliet没有jersey>1.8.1 EurekaCliet没有Jersey<a href=#181-eurekacliet没有jersey class=anchor aria-hidden=true>#</a></h4><p>默认情况下，eurekclient使用Spring的<code>RestTemplate</code>进行HTTP通信。如果您希望使用Jersey，则需要将Jersey依赖项添加到类路径中。下面的例子显示了你需要添加的包管理文件中:</p><div class=highlight><pre class=chroma><code class=language-fallback data-lang=fallback>&lt;dependency&gt;
    &lt;groupId&gt;com.sun.jersey&lt;/groupId&gt;
    &lt;artifactId&gt;jersey-client&lt;/artifactId&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;com.sun.jersey&lt;/groupId&gt;
    &lt;artifactId&gt;jersey-core&lt;/artifactId&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;com.sun.jersey.contribs&lt;/groupId&gt;
    &lt;artifactId&gt;jersey-apache-client4&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre></div><h3 id=19-替代原生netflix-eurakaclient>1.9 替代原生Netflix EurakaClient<a href=#19-替代原生netflix-eurakaclient class=anchor aria-hidden=true>#</a></h3><p>你不需要使用原始的<code>Netflix eurekclient</code>。在某种封装后面使用它通常更方便。Spring Cloud通过逻辑的Eureka服务标识符(VIPs)而不是物理url支持<code>Feign</code>(一个REST客户端构建器)和<code>Spring RestTemplate</code>的远程调用。你还可以使用<code>org.springframework.cloud.client.discovery.DiscoveryClient</code>它为发现客户端提供了一个简单的API(不特定于Netflix)，如下面的示例所示:</p><div class=highlight><pre class=chroma><code class=language-java data-lang=java><span class=nd>@Autowired</span>
<span class=kd>private</span> <span class=n>DiscoveryClient</span> <span class=n>discoveryClient</span><span class=o>;</span>

<span class=kd>public</span> <span class=n>String</span> <span class=nf>serviceUrl</span><span class=o>()</span> <span class=o>{</span>
    <span class=n>List</span><span class=o>&lt;</span><span class=n>ServiceInstance</span><span class=o>&gt;</span> <span class=n>list</span> <span class=o>=</span> <span class=n>discoveryClient</span><span class=o>.</span><span class=na>getInstances</span><span class=o>(</span><span class=s>&#34;STORES&#34;</span><span class=o>);</span>
    <span class=k>if</span> <span class=o>(</span><span class=n>list</span> <span class=o>!=</span> <span class=kc>null</span> <span class=o>&amp;&amp;</span> <span class=n>list</span><span class=o>.</span><span class=na>size</span><span class=o>()</span> <span class=o>&gt;</span> <span class=n>0</span> <span class=o>)</span> <span class=o>{</span>
        <span class=k>return</span> <span class=n>list</span><span class=o>.</span><span class=na>get</span><span class=o>(</span><span class=n>0</span><span class=o>).</span><span class=na>getUri</span><span class=o>();</span>
    <span class=o>}</span>
    <span class=k>return</span> <span class=kc>null</span><span class=o>;</span>
<span class=o>}</span>
</code></pre></div><h3 id=110-为什么注册服务如此缓慢>1.10 为什么注册服务如此缓慢<a href=#110-为什么注册服务如此缓慢 class=anchor aria-hidden=true>#</a></h3><p>作为一个实例还涉及到到注册中心的周期性心跳(通过客户机的serviceUrl)，默认持续时间为30秒。在实例、服务器和客户端本地缓存中都有相同的元数据之前，客户端无法发现服务(因此可能需要3次心跳)。可以通过设置<code>eureka.instance.leaseRenewalIntervalInSeconds</code>来修改周期。将其设置为小于30的值将加快使客户端连接到其他服务的过程。在生产中，使用默认值可能更好，因为服务器中的内部计算会对租期续期做出假设。</p><h3 id=111-zones>1.11 Zones<a href=#111-zones class=anchor aria-hidden=true>#</a></h3><p>如果您已经将Eureka客户端部署到多个区域，您可能希望这些客户端在尝试其他区域中的服务之前先使用相同区域中的服务。要进行设置，需要正确配置Eureka客户端。
首先，您需要确保将Eureka服务器部署到每个区域，并且它们彼此是对等的。有关更多信息，请参阅区域和地区一节。</p><p>接下来，你需要告诉Eureka你的服务在哪个区域。可以通过使用<code>metadatmap</code>属性来实现。例如，service 1同时部署在zone 1和zone 2，则需要在service 1中设置如下Eureka属性:</p><p><strong>Service 1 in Zone 1</strong></p><div class=highlight><pre class=chroma><code class=language-yml data-lang=yml><span class=l>eureka.instance.metadataMap.zone = zone1</span><span class=w>
</span><span class=w></span><span class=l>eureka.client.preferSameZoneEureka = true</span><span class=w>
</span></code></pre></div><p><strong>Service 1 in Zone 2</strong></p><div class=highlight><pre class=chroma><code class=language-yml data-lang=yml><span class=l>eureka.instance.metadataMap.zone = zone2</span><span class=w>
</span><span class=w></span><span class=l>eureka.client.preferSameZoneEureka = true</span><span class=w>
</span></code></pre></div><h3 id=112-刷新eureka客户端>1.12 刷新Eureka客户端<a href=#112-刷新eureka客户端 class=anchor aria-hidden=true>#</a></h3><p>默认情况下，<code>EurekaClient bean</code>是可刷新的，这意味着可以更改和刷新Eureka客户机属性。当刷新发生时，客户端将从Eureka服务器注销，并且可能有一段短暂的时间内给定服务的所有实例都不可用。消除这种情况的一种方法是禁用刷新Eureka客户机的功能。设置<code>eureka.client.refresh.enable=false</code>。</p><h3 id=113-使用springcloud负载均衡的eureka>1.13 使用SpringCloud负载均衡的Eureka<a href=#113-使用springcloud负载均衡的eureka class=anchor aria-hidden=true>#</a></h3><p>我们提供对<code>Spring CLoud LoadBalancer ZonePreferenceServiceInstanceListSupplier</code>的支持。Eureka实例元数据(Eureka.instance. metadatmap zone)中的zone值用于设置spring-cloud-loadbalancer-zone属性的值，该属性用于按zone过滤服务实例。</p><p>如果没有这个属性，并且<code>spring.cloud.loadbalancer.eureka.approximateZoneFromHostname</code>标志被设置为true，那么它可以使用服务器主机名中的域名作为区域的代理。</p><p>如果没有其他区域数据来源，则基于客户端配置（而不是实例配置）进行猜测。 我们采取<code>eureka.client.availabilityZones</code>，它是从区域名称到区域列表的地图，并释放了实例自己的区域的第一个区域（即<code>eureka.client.region</code>，默认为<code>us-east-1</code>，用于与本机Netflix的兼容性）。</p><h2 id=2-服务发现eureka服务端>2 服务发现：Eureka服务端<a href=#2-服务发现eureka服务端 class=anchor aria-hidden=true>#</a></h2><p>介绍搭建Eureka服务器的操作步骤。</p><h3 id=21-如何包含eureka服务端>2.1 如何包含Eureka服务端<a href=#21-如何包含eureka服务端 class=anchor aria-hidden=true>#</a></h3><p>要将<code>Eureka Server</code>包含到您的项目中，使用gourp ID为<code>org.springframework.cloud</code>和 artifact ID为<code>spring-cloud-start-netflix- Eureka-Server</code>的启动器。有关使用当前<code>Spring Cloud Release Train</code>设置构建系统的详细信息，请参阅Spring Cloud Project页面。</p><blockquote><p>如果您的项目已经使用<code>Thymeleaf</code>作为模板引擎，Eureka服务器的<code>Freemarker</code>模板可能无法正确加载。在这种情况下，有必要手动配置模板加载器:</p></blockquote><p><strong>application.yml</strong></p><div class=highlight><pre class=chroma><code class=language-yml data-lang=yml><span class=nt>spring</span><span class=p>:</span><span class=w>
</span><span class=w>  </span><span class=nt>freemarker</span><span class=p>:</span><span class=w>
</span><span class=w>    </span><span class=nt>template-loader-path</span><span class=p>:</span><span class=w> </span><span class=l>classpath:/templates/</span><span class=w>
</span><span class=w>    </span><span class=nt>prefer-file-system-access</span><span class=p>:</span><span class=w> </span><span class=kc>false</span><span class=w>
</span></code></pre></div><h3 id=22-如何运行eureka服务端>2.2 如何运行Eureka服务端<a href=#22-如何运行eureka服务端 class=anchor aria-hidden=true>#</a></h3><p>下面的例子展示了一个最小的Eureka服务器:</p><div class=highlight><pre class=chroma><code class=language-java data-lang=java><span class=nd>@SpringBootApplication</span>
<span class=nd>@EnableEurekaServer</span>
<span class=kd>public</span> <span class=kd>class</span> <span class=nc>Application</span> <span class=o>{</span>

    <span class=kd>public</span> <span class=kd>static</span> <span class=kt>void</span> <span class=nf>main</span><span class=o>(</span><span class=n>String</span><span class=o>[]</span> <span class=n>args</span><span class=o>)</span> <span class=o>{</span>
        <span class=k>new</span> <span class=n>SpringApplicationBuilder</span><span class=o>(</span><span class=n>Application</span><span class=o>.</span><span class=na>class</span><span class=o>).</span><span class=na>web</span><span class=o>(</span><span class=kc>true</span><span class=o>).</span><span class=na>run</span><span class=o>(</span><span class=n>args</span><span class=o>);</span>
    <span class=o>}</span>

<span class=o>}</span>
</code></pre></div><p>服务器具有主页，其中包含UI界面和HTTP API端点，作用与/eureka/*。</p><p>以下链接有一些Eureka背景知识，<a href=https://github.com/cfregly/fluxcapacitor/wiki/NetflixOSS-FAQ#eureka-service-discovery-load-balancer>flux capacitor</a> and <a href=https://groups.google.com/forum/?fromgroups#!topic/eureka_netflix/g3p2r7gHnN0>google group discussion</a>.</p><p>由于Gradle的依赖解析规则和缺少父bom特性，依赖<code>spring-cloud-start-netflix-eureka-server</code>可能会导致应用启动失败。为了解决这个问题，添加<code>Spring Boot Gradle</code>插件，并导入Spring云启动器的父bom如下:</p><p><strong>build.gradle</strong></p><div class=highlight><pre class=chroma><code class=language-gradle data-lang=gradle><span class=n>buildscript</span> <span class=o>{</span>
  <span class=n>dependencies</span> <span class=o>{</span>
    <span class=n>classpath</span><span class=o>(</span><span class=s2>&#34;org.springframework.boot:spring-boot-gradle-plugin:{spring-boot-docs-version}&#34;</span><span class=o>)</span>
  <span class=o>}</span>
<span class=o>}</span>

<span class=n>apply</span> <span class=nl>plugin:</span> <span class=s2>&#34;spring-boot&#34;</span>

<span class=n>dependencyManagement</span> <span class=o>{</span>
  <span class=n>imports</span> <span class=o>{</span>
    <span class=n>mavenBom</span> <span class=s2>&#34;org.springframework.cloud:spring-cloud-dependencies:{spring-cloud-version}&#34;</span>
  <span class=o>}</span>
<span class=o>}</span>
</code></pre></div><h3 id=23-高可用区域和地区>2.3 高可用，区域和地区<a href=#23-高可用区域和地区 class=anchor aria-hidden=true>#</a></h3><p>Eureka服务器没有后端存储，但是注册中心中的服务实例都必须发送心跳以保持其状态的更新(所以这可以在内存中完成)。客户端也有一个Eureka注册的内存缓存(所以他们不必为每个服务请求都去注册中心)。
默认情况下，每个Eureka服务器也是一个Eureka客户端，并且需要(至少一个)服务URL来定位对等点。如果你不提供它，服务也会运行并工作，但它会用许多关于无法注册进对等注册中心的信息记录填充你的日志。</p><h3 id=24-独立模式>2.4 独立模式<a href=#24-独立模式 class=anchor aria-hidden=true>#</a></h3><p>两个缓存(客户端和服务器)和心跳的结合使独立的Eureka服务器在故障时相当有弹性，只要有某种监控或弹性运行时(如Cloud Foundry)保持它的活力。在独立模式下，你可能更希望关闭客户端行为，这样它就不会一直尝试访问其他节点而失败。下面的例子展示了如何关闭客户端行为:</p><p><strong>application.yml (独立的Eureka服务器)</strong></p><div class=highlight><pre class=chroma><code class=language-yml data-lang=yml><span class=nt>server</span><span class=p>:</span><span class=w>
</span><span class=w>  </span><span class=nt>port</span><span class=p>:</span><span class=w> </span><span class=m>8761</span><span class=w>
</span><span class=w>
</span><span class=w></span><span class=nt>eureka</span><span class=p>:</span><span class=w>
</span><span class=w>  </span><span class=nt>instance</span><span class=p>:</span><span class=w>
</span><span class=w>    </span><span class=nt>hostname</span><span class=p>:</span><span class=w> </span><span class=l>localhost</span><span class=w>
</span><span class=w>  </span><span class=nt>client</span><span class=p>:</span><span class=w>
</span><span class=w>    </span><span class=nt>registerWithEureka</span><span class=p>:</span><span class=w> </span><span class=kc>false</span><span class=w>
</span><span class=w>    </span><span class=nt>fetchRegistry</span><span class=p>:</span><span class=w> </span><span class=kc>false</span><span class=w>
</span><span class=w>    </span><span class=nt>serviceUrl</span><span class=p>:</span><span class=w>
</span><span class=w>      </span><span class=nt>defaultZone</span><span class=p>:</span><span class=w> </span><span class=l>http://${eureka.instance.hostname}:${server.port}/eureka/</span><span class=w>
</span></code></pre></div><p>注意<code>serviceUrl</code>指向与本地实例相同的主机。</p><h3 id=25-对等模式>2.5 对等模式<a href=#25-对等模式 class=anchor aria-hidden=true>#</a></h3><p>通过运行多个实例并要求它们相互注册，Eureka可以变得更加灵活和可用。事实上，这是默认的行为，所以你只需要向对等体添加一个有效的serviceUrl，如下面的例子所示:</p><p><strong>application.yml (两个对等的Eureka服务器)</strong></p><div class=highlight><pre class=chroma><code class=language-yml data-lang=yml><span class=nn>---</span><span class=w>
</span><span class=w></span><span class=nt>spring</span><span class=p>:</span><span class=w>
</span><span class=w>  </span><span class=nt>profiles</span><span class=p>:</span><span class=w> </span><span class=l>peer1</span><span class=w>
</span><span class=w></span><span class=nt>eureka</span><span class=p>:</span><span class=w>
</span><span class=w>  </span><span class=nt>instance</span><span class=p>:</span><span class=w>
</span><span class=w>    </span><span class=nt>hostname</span><span class=p>:</span><span class=w> </span><span class=l>peer1</span><span class=w>
</span><span class=w>  </span><span class=nt>client</span><span class=p>:</span><span class=w>
</span><span class=w>    </span><span class=nt>serviceUrl</span><span class=p>:</span><span class=w>
</span><span class=w>      </span><span class=nt>defaultZone</span><span class=p>:</span><span class=w> </span><span class=l>https://peer2/eureka/</span><span class=w>
</span><span class=w>
</span><span class=w></span><span class=nn>---</span><span class=w>
</span><span class=w></span><span class=nt>spring</span><span class=p>:</span><span class=w>
</span><span class=w>  </span><span class=nt>profiles</span><span class=p>:</span><span class=w> </span><span class=l>peer2</span><span class=w>
</span><span class=w></span><span class=nt>eureka</span><span class=p>:</span><span class=w>
</span><span class=w>  </span><span class=nt>instance</span><span class=p>:</span><span class=w>
</span><span class=w>    </span><span class=nt>hostname</span><span class=p>:</span><span class=w> </span><span class=l>peer2</span><span class=w>
</span><span class=w>  </span><span class=nt>client</span><span class=p>:</span><span class=w>
</span><span class=w>    </span><span class=nt>serviceUrl</span><span class=p>:</span><span class=w>
</span><span class=w>      </span><span class=nt>defaultZone</span><span class=p>:</span><span class=w> </span><span class=l>https://peer1/eureka/</span><span class=w>
</span></code></pre></div><p>在上面的示例中，我们有一个YAML文件，可以通过在不同的Spring文件中配置运行它来在两台主机(peer1和peer2)上运行相同的服务器。通过操作<code>/etc/hosts</code>解析主机名，您可以使用此配置在单个主机上测试对等感知(在生产中这样做没有多大价值)。事实上，如果运行在知道自己主机名的机器上(默认情况下，使用<code>java.net.InetAddress</code>查找)，就不需要<code>eureka.instance.hostname</code>。</p><p>你可以在一个系统中添加多个对等体，只要它们彼此至少有一个连接，它们就会同步自己的注册。如果对等点在物理上是分离的(在一个数据中心内或多个数据中心之间)，那么系统原则上可以承受<code>split-brain</code>类型的故障。你可以在一个系统中添加多个对等体，只要它们都是直接连接的，它们就会在自己之间同步注册。</p><p><strong>application.yml (三个对等的eureka服务器)</strong></p><div class=highlight><pre class=chroma><code class=language-yml data-lang=yml><span class=nt>eureka</span><span class=p>:</span><span class=w>
</span><span class=w>  </span><span class=nt>client</span><span class=p>:</span><span class=w>
</span><span class=w>    </span><span class=nt>serviceUrl</span><span class=p>:</span><span class=w>
</span><span class=w>      </span><span class=nt>defaultZone</span><span class=p>:</span><span class=w> </span><span class=l>https://peer1/eureka/,http://peer2/eureka/,http://peer3/eureka/</span><span class=w>
</span><span class=w>
</span><span class=w></span><span class=nn>---</span><span class=w>
</span><span class=w></span><span class=nt>spring</span><span class=p>:</span><span class=w>
</span><span class=w>  </span><span class=nt>profiles</span><span class=p>:</span><span class=w> </span><span class=l>peer1</span><span class=w>
</span><span class=w></span><span class=nt>eureka</span><span class=p>:</span><span class=w>
</span><span class=w>  </span><span class=nt>instance</span><span class=p>:</span><span class=w>
</span><span class=w>    </span><span class=nt>hostname</span><span class=p>:</span><span class=w> </span><span class=l>peer1</span><span class=w>
</span><span class=w>
</span><span class=w></span><span class=nn>---</span><span class=w>
</span><span class=w></span><span class=nt>spring</span><span class=p>:</span><span class=w>
</span><span class=w>  </span><span class=nt>profiles</span><span class=p>:</span><span class=w> </span><span class=l>peer2</span><span class=w>
</span><span class=w></span><span class=nt>eureka</span><span class=p>:</span><span class=w>
</span><span class=w>  </span><span class=nt>instance</span><span class=p>:</span><span class=w>
</span><span class=w>    </span><span class=nt>hostname</span><span class=p>:</span><span class=w> </span><span class=l>peer2</span><span class=w>
</span><span class=w>
</span><span class=w></span><span class=nn>---</span><span class=w>
</span><span class=w></span><span class=nt>spring</span><span class=p>:</span><span class=w>
</span><span class=w>  </span><span class=nt>profiles</span><span class=p>:</span><span class=w> </span><span class=l>peer3</span><span class=w>
</span><span class=w></span><span class=nt>eureka</span><span class=p>:</span><span class=w>
</span><span class=w>  </span><span class=nt>instance</span><span class=p>:</span><span class=w>
</span><span class=w>    </span><span class=nt>hostname</span><span class=p>:</span><span class=w> </span><span class=l>peer3</span><span class=w>
</span></code></pre></div><h3 id=26-何时选择ip地址>2.6 何时选择IP地址<a href=#26-何时选择ip地址 class=anchor aria-hidden=true>#</a></h3><p>在某些情况下，Eureka最好发布服务的IP地址而不是主机名。设置<code>eureka.instance.preferipaddress=true</code>，当应用程序向eureka注册时，它使用它的IP地址而不是它的主机名。</p><blockquote><p>如果主机名不能由Java确定，则将IP地址发送给Eureka。设置主机名的唯一方法是设置eureka.instance.hostname属性。你可以在运行时使用环境变量设置主机名—例如：<code>eureka.instance.hostname=${HOST_NAME}</code>。</p></blockquote><h3 id=27-保护eureka服务器>2.7 保护Eureka服务器<a href=#27-保护eureka服务器 class=anchor aria-hidden=true>#</a></h3><p>只需通过<code>Spring-boot-starter-Security</code>将<code>Spring Security</code>添加到服务器的包管理文件中，就可以保护Eureka服务器。默认情况下，当Spring Security在包管理文件中，它将要求一个有效的CSRF令牌被发送到应用程序。Eureka客户端通常不会拥有一个有效的跨站请求伪造(CSRF)令牌，你需要为<code>/Eureka/**</code>端点禁用这个要求。例如:</p><div class=highlight><pre class=chroma><code class=language-java data-lang=java><span class=nd>@EnableWebSecurity</span>
<span class=kd>class</span> <span class=nc>WebSecurityConfig</span> <span class=kd>extends</span> <span class=n>WebSecurityConfigurerAdapter</span> <span class=o>{</span>

    <span class=nd>@Override</span>
    <span class=kd>protected</span> <span class=kt>void</span> <span class=nf>configure</span><span class=o>(</span><span class=n>HttpSecurity</span> <span class=n>http</span><span class=o>)</span> <span class=kd>throws</span> <span class=n>Exception</span> <span class=o>{</span>
        <span class=n>http</span><span class=o>.</span><span class=na>csrf</span><span class=o>().</span><span class=na>ignoringAntMatchers</span><span class=o>(</span><span class=s>&#34;/eureka/**&#34;</span><span class=o>);</span>
        <span class=kd>super</span><span class=o>.</span><span class=na>configure</span><span class=o>(</span><span class=n>http</span><span class=o>);</span>
    <span class=o>}</span>
<span class=o>}</span>
</code></pre></div><p>有关CSRF的更多信息，请参阅<a href=https://docs.spring.io/spring-security/site/docs/current/reference/htmlsingle/#csrf>Spring Security</a>文档。
在Spring Cloud Samples <a href=https://github.com/spring-cloud-samples/eureka/tree/Eureka-With-Security>repo</a>中可以找到一个演示Eureka Server。</p><h3 id=28-jdk11支持>2.8 JDK11支持<a href=#28-jdk11支持 class=anchor aria-hidden=true>#</a></h3><p>JDK 11删除了Eureka服务器所依赖的JAXB模块。如果你想在运行Eureka服务器时使用JDK 11，你必须在你的POM或Gradle文件中包含这些依赖项。</p><div class=highlight><pre class=chroma><code class=language-fallback data-lang=fallback>&lt;dependency&gt;
    &lt;groupId&gt;org.glassfish.jaxb&lt;/groupId&gt;
    &lt;artifactId&gt;jaxb-runtime&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre></div><h2 id=3-配置属性>3 配置属性<a href=#3-配置属性 class=anchor aria-hidden=true>#</a></h2><p>要查看所有Spring Cloud Netflix相关配置属性的列表，请检查<a href=https://docs.spring.io/spring-cloud-netflix/docs/current/reference/html/appendix.html>附录页面</a>。</p><p class=edit-page><a href=https://github.com/KevinBlandy/springcloud.io//blob/master/content/docs/SpringCloud/Spring%20Cloud%20Netflix.md><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-edit-2"><path d="M17 3a2.828 2.828.0 114 4L7.5 20.5 2 22l1.5-5.5L17 3z"/></svg>Edit this page on GitHub</a></p><div class=my-n3></div></main></div></div></div><footer class="footer text-muted"><div class=container><div class=row><div class="col-lg-8 order-last order-lg-first"><ul class=list-inline><li class=list-inline-item>Powered by <a href=https://www.netlify.com/>Netlify</a>, <a href=https://gohugo.io/>Hugo</a>, and <a href=https://getdoks.org/>Doks</a></li></ul></div><div class="col-lg-8 order-first order-lg-last text-lg-end"><ul class=list-inline><li class=list-inline-item><a href=https://www.springcloud.io/about/>关于</a></li><li class=list-inline-item><a href=https://www.springcloud.io/thanks/>鸣谢</a></li><li class=list-inline-item><a href=https://github.com/KevinBlandy/springcloud.io>Github</a></li><li class=list-inline-item><a href=https://springboot.io>论坛</a></li></ul></div></div></div></footer><script src=https://www.springcloud.io/js/bootstrap.min.d67050adf5d370668aede4201f82af781b16970934804995a1ca37c1ee9222c2fc530972aa6d5d2b6124caf1fe318f139aac99df2c1e89af65504fc1185c7972.js integrity="sha512-1nBQrfXTcGaK7eQgH4KveBsWlwk0gEmVoco3we6SIsL8Uwlyqm1dK2EkyvH+MY8TmqyZ3yweia9lUE/BGFx5cg==" crossorigin=anonymous defer></script><script src=https://www.springcloud.io/js/highlight.min.21fbbff4ae23e5143eb2cab64edbdb48eb90be561eb53ee5766f2ef52ef0a1c917325706a2cdd769342b64b418c3b3030d8272769e72be6d3798fa05b0018c08.js integrity="sha512-Ifu/9K4j5RQ+ssq2TtvbSOuQvlYetT7ldm8u9S7wockXMlcGos3XaTQrZLQYw7MDDYJydp5yvm03mPoFsAGMCA==" crossorigin=anonymous defer></script><script src=https://www.springcloud.io/main.min.773144977fe359704aa8b57933ee2f435ba70c66684dfa06b01c50cf8131162bd2680301697f8d788259ff49ea7dc4d5f02683ad9ed0d53f22e99dddaeab1bab.js integrity="sha512-dzFEl3/jWXBKqLV5M+4vQ1unDGZoTfoGsBxQz4ExFivSaAMBaX+NeIJZ/0nqfcTV8CaDrZ7Q1T8i6Z3drqsbqw==" crossorigin=anonymous defer></script><script src=https://www.springcloud.io/index.min.3f0f46b8b0ed5034dfea20e2d7446efb5279f217703d29aed1fde7e1785276697fcc47ab9a9cb44d7c6f88ca263cd1f09842053695effde585a35f511c472dc3.js integrity="sha512-Pw9GuLDtUDTf6iDi10Ru+1J58hdwPSmu0f3n4XhSdml/zEermpy0TXxviMomPNHwmEIFNpXv/eWFo19RHEctww==" crossorigin=anonymous defer></script></body></html>