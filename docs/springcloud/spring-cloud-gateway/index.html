<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="ie=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><link rel=preload as=font href=https://www.springcloud.io/fonts/vendor/jost/jost-v4-latin-regular.woff2 type=font/woff2 crossorigin><link rel=preload as=font href=https://www.springcloud.io/fonts/vendor/jost/jost-v4-latin-700.woff2 type=font/woff2 crossorigin><link rel=stylesheet href=https://www.springcloud.io/main.210e3fd96822b9043a12fe33ba94f308d981d4b7afee23cc6b49221906f47a69bea0700754f115f6d85627b3652ca9a96c322dc54c001ee2d03d972841695f93.css integrity="sha512-IQ4/2WgiuQQ6Ev4zupTzCNmB1Lev7iPMa0kiGQb0emm+oHAHVPEV9thWJ7NlLKmpbDItxUwAHuLQPZcoQWlfkw==" crossorigin=anonymous><noscript><style>img.lazyload{display:none}</style></noscript><meta name=keywords content="springcloud官方,springcloud中文文档,springcloud最新文档,springcloud中国"><meta name=robots content="index, follow"><meta name=googlebot content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1"><meta name=bingbot content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1"><title>Spring Cloud Gateway - SpringCloud中文社区</title><meta name=description content="该项目提供了一个库，用于在Spring WebFlux之上构建API网关。Spring Cloud Gateway旨在提供一种简单而有效的方式来路由到API，并为其提供交叉关注，如：安全、监控/指标和弹性。"><link rel=canonical href=https://www.springcloud.io/docs/springcloud/spring-cloud-gateway/><meta property="og:locale" content="zh-CN"><meta property="og:type" content="article"><meta property="og:title" content="Spring Cloud Gateway"><meta property="og:description" content="该项目提供了一个库，用于在Spring WebFlux之上构建API网关。Spring Cloud Gateway旨在提供一种简单而有效的方式来路由到API，并为其提供交叉关注，如：安全、监控/指标和弹性。"><meta property="og:url" content="https://www.springcloud.io/docs/springcloud/spring-cloud-gateway/"><meta property="og:site_name" content="SpringCloud中文社区"><meta property="article:published_time" content="2020-11-12T13:26:54+01:00"><meta property="article:modified_time" content="2020-11-12T13:26:54+01:00"><meta property="og:image" content="https://www.springcloud.io/doks.png"><meta property="og:image:alt" content="SpringCloud中文社区"><meta name=twitter:card content="summary_large_image"><meta name=twitter:site content="@getdoks"><meta name=twitter:creator content="@henkverlinde"><meta name=twitter:title content="Spring Cloud Gateway"><meta name=twitter:description content="该项目提供了一个库，用于在Spring WebFlux之上构建API网关。Spring Cloud Gateway旨在提供一种简单而有效的方式来路由到API，并为其提供交叉关注，如：安全、监控/指标和弹性。"><meta name=twitter:image content="https://www.springcloud.io/doks.png"><meta name=twitter:image:alt content="Spring Cloud Gateway"><script type=application/ld+json>{"@context":"https://schema.org","@graph":[{"@type":"Organization","@id":"https://www.springcloud.io/#/schema/organization/1","name":"Doks","url":"https://www.springcloud.io/","sameAs":["https://twitter.com/kevinblandy","https://github.com/KevinBlandy"],"logo":{"@type":"ImageObject","@id":"https://www.springcloud.io/#/schema/image/1","url":"https://www.springcloud.io/logo-doks.png","width":512,"height":512,"caption":"Doks"},"image":{"@id":"https://www.springcloud.io/#/schema/image/1"}},{"@type":"WebSite","@id":"https://www.springcloud.io/#/schema/website/1","url":"https://www.springcloud.io/","name":"SpringCloud中文社区","description":"SpringCloud中文社区专注于文档汉化，更新，以及行业前沿资讯的发布。","publisher":{"@id":"https://www.springcloud.io/#/schema/organization/1"}},{"@type":"WebPage","@id":"https://www.springcloud.io/docs/springcloud/spring-cloud-gateway/","url":"https://www.springcloud.io/docs/springcloud/spring-cloud-gateway/","name":"Spring Cloud Gateway","description":"该项目提供了一个库，用于在Spring WebFlux之上构建API网关。Spring Cloud Gateway旨在提供一种简单而有效的方式来路由到API，并为其提供交叉关注，如：安全、监控\/指标和弹性。","isPartOf":{"@id":"https://www.springcloud.io/#/schema/website/1"},"about":{"@id":"https://www.springcloud.io/#/schema/organization/1"},"datePublished":"2020-11-12T13:26:54CET","dateModified":"2020-11-12T13:26:54CET","breadcrumb":{"@id":"https://www.springcloud.io/docs/springcloud/spring-cloud-gateway/#/schema/breadcrumb/1"},"primaryImageOfPage":{"@id":"https://www.springcloud.io/docs/springcloud/spring-cloud-gateway/#/schema/image/2"},"inLanguage":"en-US","potentialAction":[{"@type":"ReadAction","target":["https://www.springcloud.io/docs/springcloud/spring-cloud-gateway/"]}]},{"@type":"BreadcrumbList","@id":"https://www.springcloud.io/docs/springcloud/spring-cloud-gateway/#/schema/breadcrumb/1","name":"Breadcrumbs","itemListElement":[{"@type":"ListItem","position":1,"item":{"@type":"WebPage","@id":"https://www.springcloud.io","url":"https://www.springcloud.io","name":"Home"}},{"@type":"ListItem","position":3,"item":{"@type":"WebPage","@id":"https://www.springcloud.io/docs/","url":"https://www.springcloud.io/docs/","name":"Docs"}},{"@type":"ListItem","position":4,"item":{"@type":"WebPage","@id":"https://www.springcloud.io/docs/springcloud/","url":"https://www.springcloud.io/docs/springcloud/","name":"Springcloud"}},{"@type":"ListItem","position":5,"item":{"@id":"https://www.springcloud.io/docs/springcloud/spring-cloud-gateway/"}}]},{"@context":"https://schema.org","@graph":[{"@type":"Article","@id":"https://www.springcloud.io/#/schema/article/1","headline":"Spring Cloud Gateway","description":"该项目提供了一个库，用于在Spring WebFlux之上构建API网关。Spring Cloud Gateway旨在提供一种简单而有效的方式来路由到API，并为其提供交叉关注，如：安全、监控\/指标和弹性。","isPartOf":{"@id":"https://www.springcloud.io/docs/springcloud/spring-cloud-gateway/"},"mainEntityOfPage":{"@id":"https://www.springcloud.io/docs/springcloud/spring-cloud-gateway/"},"datePublished":"2020-11-12T13:26:54CET","dateModified":"2020-11-12T13:26:54CET","author":{"@id":"https://www.springcloud.io/#/schema/person/2"},"publisher":{"@id":"https://www.springcloud.io/#/schema/organization/1"},"image":{"@id":"https://www.springcloud.io/docs/springcloud/spring-cloud-gateway/#/schema/image/2"}}]},{"@context":"https://schema.org","@graph":[{"@type":"Person","@id":"https://www.springcloud.io/#/schema/person/2","name":"kevinblandy","sameAs":["https://twitter.com/kevinblandy","https://github.com/KevinBlandy"]}]},{"@context":"https://schema.org","@graph":[{"@type":"ImageObject","@id":"https://www.springcloud.io/docs/springcloud/spring-cloud-gateway/#/schema/image/2","url":"https://www.springcloud.io/doks.png","contentUrl":"https://www.springcloud.io/doks.png","caption":"Spring Cloud Gateway"}]}]}</script><meta name=theme-color content="#fff"><link rel=apple-touch-icon sizes=180x180 href=https://www.springcloud.io/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=https://www.springcloud.io/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=https://www.springcloud.io/favicon-16x16.png><link rel=manifest crossorigin=use-credentials href=https://www.springcloud.io/site.webmanifest><script>var _hmt=_hmt||[];(function(){var a=document.createElement("script"),b;a.src="https://hm.baidu.com/hm.js?d725343fdb7604c5bd89b377295901df",b=document.getElementsByTagName("script")[0],b.parentNode.insertBefore(a,b)})()</script></head><body class="docs single"><div class="header-bar fixed-top"></div><header class="navbar fixed-top navbar-expand-md navbar-light"><div class=container><input class="menu-btn order-0" type=checkbox id=menu-btn>
<label class="menu-icon d-md-none" for=menu-btn><span class=navicon></span></label><a class="navbar-brand order-1 order-md-0 me-auto" href=https://www.springcloud.io/>SpringCloud中文社区</a>
<button id=mode class="btn btn-link order-2 order-md-4" type=button aria-label="Toggle mode">
<span class=toggle-dark><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-moon"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg></span><span class=toggle-light><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-sun"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></span></button><ul class="navbar-nav social-nav order-3 order-md-5"></ul><div class="collapse navbar-collapse order-4 order-md-1"><ul class="navbar-nav main-nav me-auto order-5 order-md-2"><li class=nav-item><a class=nav-link href=https://www.springcloud.io/docs/>中文文档</a></li><li class=nav-item><a class=nav-link href=https://www.springcloud.io/blog/>行业资讯</a></li></ul><div class="break order-6 d-md-none"></div><form class="navbar-form flex-grow-1 order-7 order-md-3"><input id=userinput class="form-control is-search" type=search placeholder="Search docs..." aria-label="Search docs..." autocomplete=off><div id=suggestions class="shadow bg-white rounded"></div></form></div></div></header><div class="wrap container" role=document><div class=content><div class="row flex-xl-nowrap"><div class="col-lg-5 col-xl-4 docs-sidebar"><nav class=docs-links aria-label="Main navigation"><ul class="list-unstyled collapsible-sidebar"><li class=mb-1><button class="btn btn-toggle align-items-center rounded collapsed" data-bs-toggle=collapse data-bs-target=#section-SpringBoot aria-expanded=false>
SpringBoot</button></li><li class=mb-1><button class="btn btn-toggle align-items-center rounded collapsed" data-bs-toggle=collapse data-bs-target=#section-SpringCloud aria-expanded=true>
SpringCloud</button><div class="collapse show" id=section-SpringCloud><ul class="btn-toggle-nav list-unstyled fw-normal pb-1 small"><li><a class="docs-link rounded" href=https://www.springcloud.io/docs/springcloud/spring-cloud-alibaba/>Spring Cloud Alibaba</a></li><li><a class="docs-link rounded" href=https://www.springcloud.io/docs/springcloud/spring-cloud-bus/>Spring Cloud Bus</a></li><li><a class="docs-link rounded" href=https://www.springcloud.io/docs/springcloud/spring-cloud-circuit-breaker/>Spring Cloud Circuit Breaker</a></li><li><a class="docs-link rounded" href=https://www.springcloud.io/docs/springcloud/spring-cloud-config/>Spring Cloud Config</a></li><li><a class="docs-link rounded" href=https://www.springcloud.io/docs/springcloud/spring-cloud-consul/>Spring Cloud Consul</a></li><li><a class="docs-link rounded active" href=https://www.springcloud.io/docs/springcloud/spring-cloud-gateway/>Spring Cloud Gateway</a></li><li><a class="docs-link rounded" href=https://www.springcloud.io/docs/springcloud/spring-cloud-kubernetes/>Spring Cloud Kubernetes</a></li><li><a class="docs-link rounded" href=https://www.springcloud.io/docs/springcloud/spring-cloud-netflix/>Spring Cloud Netflix</a></li><li><a class="docs-link rounded" href=https://www.springcloud.io/docs/springcloud/spring-cloud-openfeign/>Spring Cloud OpenFeign</a></li><li><a class="docs-link rounded" href=https://www.springcloud.io/docs/springcloud/spring-cloud-security-/>Spring Cloud Security</a></li><li><a class="docs-link rounded" href=https://www.springcloud.io/docs/springcloud/spring-cloud-sleuth/>Spring Cloud Sleuth</a></li><li><a class="docs-link rounded" href=https://www.springcloud.io/docs/springcloud/spring-cloud-zookeeper/>Spring Cloud Zookeeper</a></li></ul></div></li><li class=mb-1><button class="btn btn-toggle align-items-center rounded collapsed" data-bs-toggle=collapse data-bs-target=#section- aria-expanded=false>
Spring Cloud Stream</button><div class=collapse id=section-><ul class="btn-toggle-nav list-unstyled fw-normal pb-1 small"><li><a class="docs-link rounded" href=https://www.springcloud.io/docs/spring-cloud-stream/%E6%A6%82%E8%BF%B0/>概述</a></li><li><a class="docs-link rounded" href=https://www.springcloud.io/docs/spring-cloud-stream/rabbit-mq-binder/>Rabbit MQ Binder</a></li></ul></div></li></ul></nav></div><nav class="docs-toc d-none d-xl-block col-xl-3" aria-label="Secondary navigation"><div class=page-links><h3>On this page</h3><nav id=TableOfContents><ul><li><a href=#1-添加spring-cloud-gateway>1. 添加Spring Cloud Gateway</a></li><li><a href=#2-术语表>2. 术语表</a></li><li><a href=#3-它是如何工作的>3. 它是如何工作的</a></li><li><a href=#4-配置-route-predicate-和-gateway-filter>4. 配置 Route Predicate 和 Gateway Filter</a><ul><li><a href=#41-快捷配置>4.1. 快捷配置</a></li><li><a href=#42-完整展开的参数配置>4.2. 完整展开的参数配置</a></li></ul></li><li><a href=#5-路由-predicate-工厂>5. 路由 Predicate 工厂</a><ul><li><a href=#51-the-after-route-predicate-factory>5.1. The After Route Predicate Factory</a></li><li><a href=#52-the-before-route-predicate-factory>5.2. The Before Route Predicate Factory</a></li><li><a href=#53-the-between-route-predicate-factory>5.3. The Between Route Predicate Factory</a></li><li><a href=#54-the-cookie-route-predicate-factory>5.4. The Cookie Route Predicate Factory</a></li><li><a href=#55-the-header-route-predicate-factory>5.5. The Header Route Predicate Factory</a></li><li><a href=#56-the-host-route-predicate-factory>5.6. The Host Route Predicate Factory</a></li><li><a href=#57-the-method-route-predicate-factory>5.7. The Method Route Predicate Factory</a></li><li><a href=#58-the-path-route-predicate-factory>5.8. The Path Route Predicate Factory</a></li><li><a href=#59-the-query-route-predicate-factory>5.9. The Query Route Predicate Factory</a></li><li><a href=#510-the-remoteaddr-route-predicate-factory>5.10. The RemoteAddr Route Predicate Factory</a></li><li><a href=#511-the-weight-route-predicate-factory>5.11. The Weight Route Predicate Factory</a></li></ul></li><li><a href=#6-gatewayfilter-工厂>6. GatewayFilter 工厂</a><ul><li><a href=#61-the-addrequestheader-gatewayfilter-factory>6.1. The AddRequestHeader GatewayFilter Factory</a></li><li><a href=#62-the-addrequestparameter-gatewayfilter-factory>6.2. The AddRequestParameter GatewayFilter Factory</a></li><li><a href=#63-the-addresponseheader-gatewayfilter-factory>6.3. The AddResponseHeader GatewayFilter Factory</a></li><li><a href=#64-the-deduperesponseheader-gatewayfilter-factory>6.4. The DedupeResponseHeader GatewayFilter Factory</a></li><li><a href=#65-spring-cloud-circuitbreaker-gatewayfilter-factory>6.5. Spring Cloud CircuitBreaker GatewayFilter Factory</a></li><li><a href=#66-the-fallbackheaders-gatewayfilter-factory>6.6. The FallbackHeaders GatewayFilter Factory</a></li><li><a href=#67-the-maprequestheader-gatewayfilter-factory>6.7. The MapRequestHeader GatewayFilter Factory</a></li><li><a href=#68-the-prefixpath-gatewayfilter-factory>6.8. The PrefixPath GatewayFilter Factory</a></li><li><a href=#69-the-preservehostheader-gatewayfilter-factory>6.9. The PreserveHostHeader GatewayFilter Factory</a></li><li><a href=#610-the-requestratelimiter-gatewayfilter-factory>6.10. The RequestRateLimiter GatewayFilter Factory</a></li><li><a href=#611-the-redirectto-gatewayfilter-factory>6.11. The RedirectTo GatewayFilter Factory</a></li><li><a href=#612-the-removerequestheader-gatewayfilter-factory>6.12. The RemoveRequestHeader GatewayFilter Factory</a></li><li><a href=#613-removeresponseheader-gatewayfilter-factory>6.13. RemoveResponseHeader GatewayFilter Factory</a></li><li><a href=#614-the-removerequestparameter-gatewayfilter-factory>6.14. The RemoveRequestParameter GatewayFilter Factory</a></li><li><a href=#615-the-rewritepath-gatewayfilter-factory>6.15. The RewritePath GatewayFilter Factory</a></li><li><a href=#616-rewritelocationresponseheader-gatewayfilter-factory>6.16. RewriteLocationResponseHeader GatewayFilter Factory</a></li><li><a href=#617-the-rewriteresponseheader-gatewayfilter-factory>6.17. The RewriteResponseHeader GatewayFilter Factory</a></li><li><a href=#618-the-savesession-gatewayfilter-factory>6.18. The SaveSession GatewayFilter Factory</a></li><li><a href=#619-the-secureheaders-gatewayfilter-factory>6.19. The SecureHeaders GatewayFilter Factory</a></li><li><a href=#620-the-setpath-gatewayfilter-factory>6.20. The SetPath GatewayFilter Factory</a></li><li><a href=#621-the-setrequestheader-gatewayfilter-factory>6.21. The SetRequestHeader GatewayFilter Factory</a></li><li><a href=#622-the-setresponseheader-gatewayfilter-factory>6.22. The SetResponseHeader GatewayFilter Factory</a></li><li><a href=#623-the-setstatus-gatewayfilter-factory>6.23. The SetStatus GatewayFilter Factory</a></li><li><a href=#624-the-stripprefix-gatewayfilter-factory>6.24. The StripPrefix GatewayFilter Factory</a></li><li><a href=#625-the-retry-gatewayfilter-factory>6.25. The Retry GatewayFilter Factory</a></li><li><a href=#626-the-requestsize-gatewayfilter-factory>6.26. The RequestSize GatewayFilter Factory</a></li><li><a href=#627-the-setrequesthostheader-gatewayfilter-factory>6.27. The SetRequestHostHeader GatewayFilter Factory</a></li><li><a href=#628-modify-a-request-body-gatewayfilter-factory>6.28. Modify a Request Body GatewayFilter Factory</a></li><li><a href=#629-modify-a-response-body-gatewayfilter-factory>6.29. Modify a Response Body GatewayFilter Factory</a></li><li><a href=#630-token-relay-gatewayfilter-factory>6.30. Token Relay GatewayFilter Factory</a></li><li><a href=#631-default-filters>6.31. Default Filters</a></li></ul></li><li><a href=#7-global-filters>7. Global Filters</a><ul><li><a href=#71-combined-global-filter-and-gatewayfilter-ordering>7.1. Combined Global Filter and GatewayFilter Ordering</a></li><li><a href=#72-forward-routing-filter>7.2. Forward Routing Filter</a></li><li><a href=#73-the-reactiveloadbalancerclientfilter>7.3. The ReactiveLoadBalancerClientFilter</a></li><li><a href=#74-the-netty-routing-filter>7.4. The Netty Routing Filter</a></li><li><a href=#75-the-netty-write-response-filter>7.5. The Netty Write Response Filter</a></li><li><a href=#76-the-routetorequesturl-filter>7.6. The RouteToRequestUrl Filter</a></li><li><a href=#77-the-websocket-routing-filter>7.7. The Websocket Routing Filter</a></li><li><a href=#78-the-gateway-metrics-filter>7.8. The Gateway Metrics Filter</a></li><li><a href=#79-marking-an-exchange-as-routed>7.9. Marking An Exchange As Routed</a></li></ul></li><li><a href=#8-httpheadersfilters>8. HttpHeadersFilters</a><ul><li><a href=#81-forwarded-headers-filter>8.1. Forwarded Headers Filter</a></li><li><a href=#82-removehopbyhop-headers-filter>8.2. RemoveHopByHop Headers Filter</a></li><li><a href=#83-xforwarded-headers-filter>8.3. XForwarded Headers Filter</a></li></ul></li><li><a href=#9-tls-and-ssl>9. TLS and SSL</a><ul><li><a href=#91-tls-handshake>9.1. TLS Handshake</a></li></ul></li><li><a href=#10-configuration>10. Configuration</a></li><li><a href=#11-route-metadata-configuration>11. Route Metadata Configuration</a></li><li><a href=#12-http-timeouts-configuration>12. Http timeouts configuration</a><ul><li><a href=#121-全局超时>12.1. 全局超时</a></li><li><a href=#122-每个路由的超时>12.2. 每个路由的超时</a></li><li><a href=#123-fluent-java-routes-api>12.3. Fluent Java Routes API</a></li><li><a href=#124-the-discoveryclient-route-definition-locator>12.4. The DiscoveryClient Route Definition Locator</a></li></ul></li><li><a href=#13-reactor-netty-访问日志>13. Reactor Netty 访问日志</a></li><li><a href=#14-cors-跨域配置>14. CORS 跨域配置</a></li><li><a href=#15-actuator-api>15. Actuator API</a><ul><li><a href=#151-verbose-actuator-format>15.1. Verbose Actuator Format</a></li><li><a href=#152-retrieving-route-filters>15.2. Retrieving Route Filters</a></li><li><a href=#153-刷新路由缓存>15.3. 刷新路由缓存</a></li><li><a href=#154-检索网关中定义的路由>15.4. 检索网关中定义的路由</a></li><li><a href=#155-检索指定路由的信息>15.5. 检索指定路由的信息</a></li><li><a href=#156-创建和删除一个指定的路由>15.6. 创建和删除一个指定的路由</a></li><li><a href=#157-总结所有端点的清单>15.7. 总结：所有端点的清单</a></li></ul></li><li><a href=#16-故障排除>16. 故障排除</a><ul><li><a href=#161-日志级别>16.1. 日志级别</a></li><li><a href=#162-wiretap>16.2. Wiretap</a></li></ul></li><li><a href=#17-开发者指南>17. 开发者指南</a><ul><li><a href=#171-编写自定义路由谓语工厂>17.1. 编写自定义路由谓语工厂</a></li><li><a href=#172-编写自定义gatewayfilter工厂>17.2. 编写自定义GatewayFilter工厂</a></li><li><a href=#173-writing-custom-global-filters>17.3. Writing Custom Global Filters</a></li></ul></li><li><a href=#18-通过使用spring-mvc或webflux构建一个简单的网关>18. 通过使用Spring MVC或Webflux构建一个简单的网关</a></li><li><a href=#19-配置属性>19. 配置属性</a></li></ul></nav></div></nav><main class="docs-content col-lg-11 col-xl-9"><nav aria-label=breadcrumb><ol class=breadcrumb><li class=breadcrumb-item><a href=https://www.springcloud.io/>Home</a></li><li class=breadcrumb-item><a href=https://www.springcloud.io/docs/>Docs</a></li><li class=breadcrumb-item><a href=https://www.springcloud.io/docs/springcloud/>SpringCloud</a></li><li class="breadcrumb-item active" aria-current=page>Spring Cloud Gateway</li></ol></nav><h1>Spring Cloud Gateway</h1><p class=lead></p><ul><li>当前版本：3.0.3</li><li>修改时间：2021年7月23日</li><li>官方文档：<a href=https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/>https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/</a></li><li>源码仓库：<a href=https://github.com/spring-cloud/spring-cloud-gateway>https://github.com/spring-cloud/spring-cloud-gateway</a></li></ul><p>这个项目提供了一个建立在Spring生态系统之上的API网关，包括。Spring 5、Spring Boot 2和Project Reactor。Spring Cloud Gateway旨在提供一种简单而有效的方式来路由到API，并提供跨领域的关注，如：安全、监控/指标和弹性。</p><h2 id=1-添加spring-cloud-gateway>1. 添加Spring Cloud Gateway<a href=#1-添加spring-cloud-gateway class=anchor aria-hidden=true>#</a></h2><p>要在你的项目中包含Spring Cloud Gateway，请使用grup ID为<code>org.springframework.cloud</code>和artifact ID为<code>spring-cloud-starter-gateway</code>的starter。请参阅<a href=https://projects.spring.io/spring-cloud/>Spring Cloud项目页面</a>，了解关于使用当前Spring Cloud发布列车设置构建系统的详细信息。</p><p>如果你包含了starter，但你不希望启用网关，请设置<code>spring.cloud.gateway.enabled=false</code>。</p><blockquote><p>Spring Cloud Gateway建立在<a href=https://spring.io/projects/spring-boot#learn>Spring Boot 2.x</a>、<a href=https://docs.spring.io/spring/docs/current/spring-framework-reference/web-reactive.html>Spring WebFlux</a>和<a href=https://projectreactor.io/docs>Project Reactor</a>之上。因此，你所熟悉的许多同步库（例如Spring Data和Spring Security）和模式在你使用Spring Cloud Gateway时可能不适用。如果你不熟悉这些项目，我们建议你在使用Spring Cloud Gateway之前先阅读它们的文档，熟悉一些新的概念。</p></blockquote><blockquote><p>Spring Cloud Gateway需要Spring Boot和Spring Webflux提供的Netty运行时间。它不能在传统的Servlet容器中工作，也不能以WAR的形式构建。</p></blockquote><h2 id=2-术语表>2. 术语表<a href=#2-术语表 class=anchor aria-hidden=true>#</a></h2><ul><li><strong>Route</strong>。网关的基本构造块。它由一个ID、一个目的地URI、一个谓词集合和一个过滤器集合定义。如果集合谓词为真，则路由被匹配。</li><li><strong>Predicate</strong>。这是一个<a href=https://docs.oracle.com/javase/8/docs/api/java/util/function/Predicate.html>Java 8 Function Predicate</a>。输入类型是一个<a href=https://docs.spring.io/spring/docs/5.0.x/javadoc-api/org/springframework/web/server/ServerWebExchange.html>Spring Framework <code>ServerWebExchange</code></a>。这让你可以匹配HTTP请求中的任何内容，如头文件或参数。</li><li><strong>Filter</strong>。这些是<a href=https://github.com/spring-cloud/spring-cloud-gateway/tree/main/spring-cloud-gateway-server/src/main/java/org/springframework/cloud/gateway/filter/GatewayFilter.java><code>GatewayFilter</code></a>的实例，已经用特定的工厂构建。在这里，你可以在发送下游请求之前或之后修改请求和响应。</li></ul><h2 id=3-它是如何工作的>3. 它是如何工作的<a href=#3-它是如何工作的 class=anchor aria-hidden=true>#</a></h2><p>下图提供了一个关于Spring Cloud Gateway如何工作的高层次概述。</p><p><img src=https://cdn.jsdelivr.net/gh/KevinBlandy/springcloud-images/2021/07/23/6026b5a0b1ad41a68dee61d1af1ff5d0.png alt=springcloud></p><p>客户端向Spring Cloud Gateway发出请求。如果Gateway处理程序映射确定一个请求与路由相匹配，它将被发送到Gateway Web处理程序。这个处理程序通过一个特定于该请求的过滤器链来运行该请求。过滤器被虚线划分的原因是，过滤器可以在代理请求发送之前和之后运行逻辑。所有的 &ldquo;pre"过滤器逻辑都被执行。然后发出代理请求。在代理请求发出后，&ldquo;post"过滤器逻辑被运行。</p><blockquote><p>在路由中定义的没有端口的URI，其HTTP和HTTPS URI的默认端口值分别为80和443。</p></blockquote><h2 id=4-配置-route-predicate-和-gateway-filter>4. 配置 Route Predicate 和 Gateway Filter<a href=#4-配置-route-predicate-和-gateway-filter class=anchor aria-hidden=true>#</a></h2><p>有两种方式可以配置谓词和过滤器：快捷方式和完全展开参数。下面的大多数例子使用的是快捷方式。</p><p>名称和参数名称将在每个部分的第一或第二句中以<code>code</code>的形式列出。参数通常按照快捷方式配置所需的顺序列出。</p><h3 id=41-快捷配置>4.1. 快捷配置<a href=#41-快捷配置 class=anchor aria-hidden=true>#</a></h3><p>捷径配置是由过滤器名称识别的，后面是等号（<code>=</code>），后面是由逗号（<code>,</code>）分隔的参数值。</p><p>application.yml</p><pre><code class=language-yaml>spring:
  cloud:
    gateway:
      routes:
      - id: after_route
        uri: https://example.org
        predicates:
        - Cookie=mycookie,mycookievalue
</code></pre><p>前面的例子定义了<code>Cookie</code>路由谓词工厂，有两个参数，cookie名称<code>mycookie</code>和要匹配的值<code>mycookievalue</code>。</p><h3 id=42-完整展开的参数配置>4.2. 完整展开的参数配置<a href=#42-完整展开的参数配置 class=anchor aria-hidden=true>#</a></h3><p>完全展开的参数看起来更像标准的yaml配置，有name/vlue键值对。一般来说，会有一个<code>name</code>键和一个<code>args</code>键。<code>args</code>键是一个键值对的映射，用于配置谓词或过滤器。</p><p>application.yml</p><pre><code class=language-yaml>spring:
  cloud:
    gateway:
      routes:
      - id: after_route
        uri: https://example.org
        predicates:
        - name: Cookie
          args:
            name: mycookie
            regexp: mycookievalue
</code></pre><p>这是上面显示的<code>Cookie</code>谓词的快捷配置的完整配置。</p><h2 id=5-路由-predicate-工厂>5. 路由 Predicate 工厂<a href=#5-路由-predicate-工厂 class=anchor aria-hidden=true>#</a></h2><p>Spring Cloud Gateway将路由作为Spring WebFlux <code>HandlerMapping</code>基础设施的一部分进行匹配。Spring Cloud Gateway包括许多内置的路由谓词工厂。所有这些谓词都与HTTP请求的不同属性相匹配。你可以用逻辑上的 &ldquo;and &ldquo;语句组合多个路由谓词工厂。</p><h3 id=51-the-after-route-predicate-factory>5.1. The After Route Predicate Factory<a href=#51-the-after-route-predicate-factory class=anchor aria-hidden=true>#</a></h3><p>&ldquo;After&rdquo; 路由谓词工厂需要一个参数，即 &ldquo;datetime&rdquo;（它是java的 &ldquo;ZonedDateTime&rdquo;）。这个谓词匹配发生在指定日期时间之后的请求。下面的例子配置了一个after路线谓词。</p><p>Example 1. application.yml</p><pre><code class=language-yaml>spring:
  cloud:
    gateway:
      routes:
      - id: after_route
        uri: https://example.org
        predicates:
        - After=2017-01-20T17:42:47.789-07:00[America/Denver]
</code></pre><p>请求的时间只有在 <code>2017-01-20T17:42:47.789-07:00[America/Denver]</code> 之后才会路由请求。</p><h3 id=52-the-before-route-predicate-factory>5.2. The Before Route Predicate Factory<a href=#52-the-before-route-predicate-factory class=anchor aria-hidden=true>#</a></h3><p>&ldquo;Before"路由谓词工厂需要一个参数，即 &ldquo;datetime&rdquo;（它是一个java的 &ldquo;ZonedDateTime&rdquo;）。这个谓词匹配发生在指定的<code>datetime</code>之前的请求。下面的例子配置了一个before路由谓词。</p><p>Example 2. application.yml</p><pre><code class=language-yaml>spring:
  cloud:
    gateway:
      routes:
      - id: before_route
        uri: https://example.org
        predicates:
        - Before=2017-01-20T17:42:47.789-07:00[America/Denver]
</code></pre><p>请求的时间只有在 <code>2017-01-20T17:42:47.789-07:00[America/Denver]</code> 之前才会路由请求。</p><h3 id=53-the-between-route-predicate-factory>5.3. The Between Route Predicate Factory<a href=#53-the-between-route-predicate-factory class=anchor aria-hidden=true>#</a></h3><p><code>Between</code>路由谓词工厂需要两个参数，<code>datetime1</code>和<code>datetime2</code>，它们是java<code>ZonedDateTime</code>对象。这个谓词匹配发生在<code>datetime1</code>之后和<code>datetime2</code>之前的请求。参数<code>datetime2</code>必须在<code>datetime1</code>之后。下面的例子配置了一个路由谓词之间。</p><p>Example 3. application.yml</p><pre><code class=language-yaml>spring:
  cloud:
    gateway:
      routes:
      - id: between_route
        uri: https://example.org
        predicates:
        - Between=2017-01-20T17:42:47.789-07:00[America/Denver], 2017-01-21T17:42:47.789-07:00[America/Denver]
</code></pre><p>这条路线匹配任何在<code>2017-01-20T17:42:47.789-07:00[America/Denver]</code>之后和<code>2017-01-21T17:42:47.789-07:00[America/Denver]</code>之前发起的请求。这对维护窗口可能是有用的。</p><h3 id=54-the-cookie-route-predicate-factory>5.4. The Cookie Route Predicate Factory<a href=#54-the-cookie-route-predicate-factory class=anchor aria-hidden=true>#</a></h3><p><code>Cookie'路由谓词工厂接受两个参数，即cookie</code>名称&rsquo;和<code>regexp</code>（这是一个Java正则表达式）。这个谓词匹配具有给定名称且其值符合正则表达式的cookie。下面的例子配置了一个cookie路由谓词工厂。</p><p>Example 4. application.yml</p><pre><code class=language-yaml>spring:
  cloud:
    gateway:
      routes:
      - id: cookie_route
        uri: https://example.org
        predicates:
        - Cookie=chocolate, ch.p
</code></pre><p>这个路由匹配有一个名为 &ldquo;chocolate"的cookie的请求，其值与 &ldquo;ch.p"正则表达式匹配。</p><h3 id=55-the-header-route-predicate-factory>5.5. The Header Route Predicate Factory<a href=#55-the-header-route-predicate-factory class=anchor aria-hidden=true>#</a></h3><p>路由谓词工厂 &ldquo;Header&rdquo; 需要两个参数，header的 &ldquo;name&rdquo; 和 &ldquo;regexp&rdquo;（这是一个Java正则表达式）。这个谓词与具有给定名称且其值符合正则表达式的头匹配。下面的例子配置了一个hear的路由谓词。</p><p>Example 5. application.yml</p><pre><code class=language-yaml>spring:
  cloud:
    gateway:
      routes:
      - id: header_route
        uri: https://example.org
        predicates:
        - Header=X-Request-Id, \d+
</code></pre><p>如果请求有一个名为<code>X-Request-Id</code>的头，其值与<code>d+</code>正则表达式相匹配（即，它有一个或多个数字的值），则该路由匹配。</p><h3 id=56-the-host-route-predicate-factory>5.6. The Host Route Predicate Factory<a href=#56-the-host-route-predicate-factory class=anchor aria-hidden=true>#</a></h3><p><code>Host</code>路由谓词工厂接受一个参数：一个主机名称<code>patterns</code>的列表。模式是一个Ant风格的模式，以<code>.</code>作为分隔符。这个谓词匹配符合该模式的<code>Host</code>头。下面的例子配置了一个主机路由谓词。</p><p>Example 6. application.yml</p><pre><code class=language-yaml>spring:
  cloud:
    gateway:
      routes:
      - id: host_route
        uri: https://example.org
        predicates:
        - Host=**.somehost.org,**.anotherhost.org
</code></pre><p>也支持URI模板变量（如<code>{sub}.myhost.org</code>）。</p><p>如果请求有一个<code>Host</code>头，其值为<code>www.somehost.org</code>或<code>beta.somehost.org</code>或<code>www.anotherhost.org</code>，则该路由匹配。</p><p>这个谓词提取URI模板变量（如<code>sub</code>，在前面的例子中定义）作为名称和值的映射，并将其放在<code>ServerWebExchange.getAttributes()</code>中，其键定义在<code>ServerWebExchangeUtils.URI_TEMPLATE_VARIABLES_ATTRIBUTE</code>。然后，这些值可供<a href=https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#gateway-route-filters><code>GatewayFilter</code> factories</a> 使用。</p><h3 id=57-the-method-route-predicate-factory>5.7. The Method Route Predicate Factory<a href=#57-the-method-route-predicate-factory class=anchor aria-hidden=true>#</a></h3><p>&ldquo;Method"路由谓词工厂接受一个 &ldquo;methods"参数，这是一个或多个参数：要匹配的HTTP方法。下面的例子配置了一个方法路径谓词。</p><p>Example 7. application.yml</p><pre><code class=language-yaml>spring:
 cloud:
   gateway:
     routes:
     - id: method_route
       uri: https://example.org
       predicates:
       - Method=GET,POST
</code></pre><p>如果请求方法是 &ldquo;GET &ldquo;或 &ldquo;POST&rdquo;，则该路由匹配。</p><h3 id=58-the-path-route-predicate-factory>5.8. The Path Route Predicate Factory<a href=#58-the-path-route-predicate-factory class=anchor aria-hidden=true>#</a></h3><p>Path Route Predicate Factory需要两个参数：一个Spring <code>PathMatcher</code>模式的列表和一个可选的标志<code>matchTrailingSlash</code>（默认为<code>true</code>）。下面的例子配置了一个路径路由谓词。</p><p>Example 8. application.yml</p><pre><code class=language-yaml>spring:
  cloud:
    gateway:
      routes:
      - id: path_route
        uri: https://example.org
        predicates:
        - Path=/red/{segment},/blue/{segment}
</code></pre><p>如果请求路径是，例如：<code>/red/1</code>或<code>/red/1/</code>或<code>/red/blue</code>或<code>/blue/green</code>，则该路径匹配。</p><p>如果<code>matchTrailingSlash</code>被设置为<code>false</code>，那么请求路径<code>/red/1/</code>将不被匹配。</p><p>这个谓词提取URI模板变量（如<code>segment</code>，在前面的例子中定义）作为名称和值的映射，并将其放在<code>ServerWebExchange.getAttributes()</code>中，其键定义在<code>ServerWebExchangeUtils.URI_TEMPLATE_VARIABLES_ATTRIBUTE</code>。这些值然后可供<a href=https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#gateway-route-filters><code>GatewayFilter</code> factories</a>使用。</p><p>有一个实用的方法（称为 &ldquo;get&rdquo;），以使访问这些变量更加容易。下面的例子显示了如何使用<code>get</code>方法。</p><pre><code class=language-java>Map&lt;String, String&gt; uriVariables = ServerWebExchangeUtils.getPathPredicateVariables(exchange);

String segment = uriVariables.get(&quot;segment&quot;);
</code></pre><h3 id=59-the-query-route-predicate-factory>5.9. The Query Route Predicate Factory<a href=#59-the-query-route-predicate-factory class=anchor aria-hidden=true>#</a></h3><p>查询路由谓词工厂需要两个参数：一个必需的param和一个可选的regexp（这是一个Java正则表达式）。下面的例子配置了一个查询路由谓词。</p><p>Example 9. application.yml</p><pre><code class=language-yaml>spring:
  cloud:
    gateway:
      routes:
      - id: query_route
        uri: https://example.org
        predicates:
        - Query=green
</code></pre><p>如果请求包含一个"green"的查询参数，前面的路由就会匹配。</p><p>application.yml</p><pre><code class=language-yaml>spring:
  cloud:
    gateway:
      routes:
      - id: query_route
        uri: https://example.org
        predicates:
        - Query=red, gree.
</code></pre><p>如果请求中包含一个<code>red</code>的查询参数，其值与<code>gree.</code>的重合表达式相匹配，那么前面的路由就会匹配，所以<code>green</code>和<code>greet</code>会匹配。</p><h3 id=510-the-remoteaddr-route-predicate-factory>5.10. The RemoteAddr Route Predicate Factory<a href=#510-the-remoteaddr-route-predicate-factory class=anchor aria-hidden=true>#</a></h3><p>RemoteAddr路由谓词工厂接受一个来源列表（最小尺寸为1），它是CIDR-注解（IPv4或IPv6）字符串，如192.168.0.1/16（其中192.168.0.1是一个IP地址，16是子网掩码）。下面的例子配置了一个RemoteAddr路由谓词。</p><p>Example 10. application.yml</p><pre><code class=language-yaml>spring:
  cloud:
    gateway:
      routes:
      - id: remoteaddr_route
        uri: https://example.org
        predicates:
        - RemoteAddr=192.168.1.1/24
</code></pre><p>如果请求的远程地址是，例如，192.168.1.10，则该路由匹配。</p><h3 id=511-the-weight-route-predicate-factory>5.11. The Weight Route Predicate Factory<a href=#511-the-weight-route-predicate-factory class=anchor aria-hidden=true>#</a></h3><p>Weight路线谓语工厂需要两个参数：group 和weight （一个int）。weight 是按group计算的。下面的例子配置了一个权重路由谓词。</p><p>Example 11. application.yml</p><pre><code class=language-yaml>spring:
  cloud:
    gateway:
      routes:
      - id: weight_high
        uri: https://weighthigh.org
        predicates:
        - Weight=group1, 8
      - id: weight_low
        uri: https://weightlow.org
        predicates:
        - Weight=group1, 2
</code></pre><p>此路由将转发~80%的流量到 <code>weighthigh.org</code>，~20%的流量到<code>weightlow.org</code>。</p><h4 id=5111-modifying-the-way-remote-addresses-are-resolved>5.11.1. Modifying the Way Remote Addresses Are Resolved<a href=#5111-modifying-the-way-remote-addresses-are-resolved class=anchor aria-hidden=true>#</a></h4><p>默认情况下，RemoteAddr路由谓语工厂使用传入请求中的远程地址。如果Spring Cloud Gateway位于代理层后面，这可能与实际的客户端IP地址不一致。</p><p>你可以通过设置自定义的<code>RemoteAddressResolver</code>来定制远程地址的解析方式。Spring Cloud Gateway有一个非默认的远程地址解析器，基于<a href=https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Forwarded-For>X-Forwarded-For header</a>，<code>XForwardedRemoteAddressResolver</code>。</p><p><code>XForwardedRemoteAddressResolver</code>有两个静态构造方法，它们采取不同的安全方法。</p><ul><li><code>XForwardedRemoteAddressResolver::trustAll</code>返回一个<code>RemoteAddressResolver</code>，它总是采取在<code>X-Forwarded-For</code>头中发现的第一个IP地址。这种方法容易受到欺骗，因为恶意的客户可以为<code>X-Forwarded-For</code>设置一个初始值，这将被解析器所接受。</li><li><code>XForwardedRemoteAddressResolver::maxTrustedIndex</code>采取一个与Spring Cloud Gateway前面运行的受信任基础设施数量相关的索引。例如，如果Spring Cloud Gateway只能通过HAProxy访问，那么应该使用1的值。如果在Spring Cloud Gateway被访问之前需要两跳受信任的基础设施，那么应该使用2的值。</li></ul><p>考虑一下下面的标头值。</p><pre><code class=language-text>X-Forwarded-For: 0.0.0.1, 0.0.0.2, 0.0.0.3
</code></pre><p>以下<code>maxTrustedIndex</code>值产生以下远程地址。</p><table><thead><tr><th><code>maxTrustedIndex</code></th><th>result</th></tr></thead><tbody><tr><td>[ <code>Integer.MIN_VALUE</code> ,0]</td><td>(invalid, <code>IllegalArgumentException</code> during initialization)</td></tr><tr><td>1</td><td>0.0.0.3</td></tr><tr><td>2</td><td>0.0.0.2</td></tr><tr><td>3</td><td>0.0.0.1</td></tr><tr><td>[4, <code>Integer.MAX_VALUE</code> ]</td><td>0.0.0.1</td></tr></tbody></table><p>下面的例子显示了如何用Java实现同样的配置。</p><p>Example 12. GatewayConfig.java</p><pre><code class=language-java>RemoteAddressResolver resolver = XForwardedRemoteAddressResolver
    .maxTrustedIndex(1);

...

.route(&quot;direct-route&quot;,
    r -&gt; r.remoteAddr(&quot;10.1.1.1&quot;, &quot;10.10.1.1/24&quot;)
        .uri(&quot;https://downstream1&quot;)
.route(&quot;proxied-route&quot;,
    r -&gt; r.remoteAddr(resolver, &quot;10.10.1.1&quot;, &quot;10.10.1.1/24&quot;)
        .uri(&quot;https://downstream2&quot;)
)
</code></pre><h2 id=6-gatewayfilter-工厂>6. GatewayFilter 工厂<a href=#6-gatewayfilter-工厂 class=anchor aria-hidden=true>#</a></h2><p>路由过滤器允许以某种方式修改传入的 HTTP 请求或传出的 HTTP 响应。路由过滤器的范围是一个特定的路由。Spring Cloud Gateway包括许多内置的GatewayFilter Factories。</p><blockquote><p>关于如何使用以下任何过滤器的更详细的例子，请看<a href=https://github.com/spring-cloud/spring-cloud-gateway/tree/master/spring-cloud-gateway-server/src/test/java/org/springframework/cloud/gateway/filter/factory>单元测试</a>。</p></blockquote><h3 id=61-the-addrequestheader-gatewayfilter-factory>6.1. The AddRequestHeader GatewayFilter Factory<a href=#61-the-addrequestheader-gatewayfilter-factory class=anchor aria-hidden=true>#</a></h3><p><code>AddRequestHeader</code> <code>GatewayFilter</code>工厂需要一个<code>name</code>和<code>value</code>参数。下面的例子配置了一个<code>AddRequestHeader</code>的<code>GatewayFilter</code>。</p><p>Example 13. application.yml</p><pre><code class=language-yaml>spring:
  cloud:
    gateway:
      routes:
      - id: add_request_header_route
        uri: https://example.org
        filters:
        - AddRequestHeader=X-Request-red, blue
</code></pre><p>这个列表将<code>X-Request-red:blue</code>头添加到所有匹配请求的下游请求的头文件中。</p><p><code>AddRequestHeader</code>知道用于匹配路径或主机的URI变量。URI变量可以在值中使用，并在运行时被扩展。下面的例子配置了一个<code>AddRequestHeader``GatewayFilter</code>，使用了一个变量。</p><p>Example 14. application.yml</p><pre><code class=language-yaml>spring:
  cloud:
    gateway:
      routes:
      - id: add_request_header_route
        uri: https://example.org
        predicates:
        - Path=/red/{segment}
        filters:
        - AddRequestHeader=X-Request-Red, Blue-{segment}
</code></pre><h3 id=62-the-addrequestparameter-gatewayfilter-factory>6.2. The AddRequestParameter GatewayFilter Factory<a href=#62-the-addrequestparameter-gatewayfilter-factory class=anchor aria-hidden=true>#</a></h3><p>AddRequestParameter GatewayFilter Factory需要一个名称和值参数。下面的例子配置了一个AddRequestParameter GatewayFilter。</p><p>Example 15. application.yml</p><pre><code class=language-yaml>spring:
  cloud:
    gateway:
      routes:
      - id: add_request_parameter_route
        uri: https://example.org
        filters:
        - AddRequestParameter=red, blue
</code></pre><p>这将为所有匹配的请求在下游请求的查询字符串中添加<code>red=blue</code>。</p><p><code>AddRequestParameter</code>知道用于匹配路径或主机的URI变量。URI变量可以在值中使用，并在运行时被扩展。下面的例子配置了一个<code>AddRequestParameter``GatewayFilter</code>，使用了一个变量。</p><p>Example 16. application.yml</p><pre><code class=language-yaml>spring:
  cloud:
    gateway:
      routes:
      - id: add_request_parameter_route
        uri: https://example.org
        predicates:
        - Host: {segment}.myhost.org
        filters:
        - AddRequestParameter=foo, bar-{segment}
</code></pre><h3 id=63-the-addresponseheader-gatewayfilter-factory>6.3. The AddResponseHeader GatewayFilter Factory<a href=#63-the-addresponseheader-gatewayfilter-factory class=anchor aria-hidden=true>#</a></h3><p><code>AddResponseHeader</code> <code>GatewayFilter</code>工厂需要一个<code>name</code>和<code>value</code>参数。下面的例子配置了一个<code>AddResponseHeader</code> <code>GatewayFilter</code>。</p><p>Example 17. application.yml</p><pre><code class=language-yaml>spring:
  cloud:
    gateway:
      routes:
      - id: add_response_header_route
        uri: https://example.org
        filters:
        - AddResponseHeader=X-Response-Red, Blue
</code></pre><p>这将把<code>X-Response-Foo:Bar</code>头添加到所有匹配请求的下游响应的头文件中。</p><p><code>AddResponseHeader</code>知道用于匹配路径或主机的URI变量。URI变量可以在值中使用，并在运行时被扩展。下面的例子配置了一个<code>AddResponseHeader``GatewayFilter</code>，使用了一个变量。</p><p>Example 18. application.yml</p><pre><code class=language-yaml>spring:
  cloud:
    gateway:
      routes:
      - id: add_response_header_route
        uri: https://example.org
        predicates:
        - Host: {segment}.myhost.org
        filters:
        - AddResponseHeader=foo, bar-{segment}
</code></pre><h3 id=64-the-deduperesponseheader-gatewayfilter-factory>6.4. The DedupeResponseHeader GatewayFilter Factory<a href=#64-the-deduperesponseheader-gatewayfilter-factory class=anchor aria-hidden=true>#</a></h3><p>DedupeResponseHeader GatewayFilter工厂接收一个<code>name</code>参数和一个可选的<code>strategy</code>参数。<code>name</code>可以包含一个以空格分隔的头名称列表。下面的例子配置了一个<code>DedupeResponseHeader</code> <code>GatewayFilter</code>。</p><pre><code class=language-yaml>spring:
  cloud:
    gateway:
      routes:
      - id: dedupe_response_header_route
        uri: https://example.org
        filters:
        - DedupeResponseHeader=Access-Control-Allow-Credentials Access-Control-Allow-Origin
</code></pre><p>在网关CORS逻辑和下游逻辑都添加了<code>Access-Control-Allow-Credentials</code>和<code>Access-Control-Allow-Origin</code>响应头的情况下，这将删除重复的值。</p><p>DedupeResponseHeader 过滤器还接受一个可选的 <code>strategy</code> 参数。接受的值是<code>RETAIN_FIRST</code>（默认），<code>RETAIN_LAST</code>，和<code>RETAIN_UNIQUE</code>。</p><h3 id=65-spring-cloud-circuitbreaker-gatewayfilter-factory>6.5. Spring Cloud CircuitBreaker GatewayFilter Factory<a href=#65-spring-cloud-circuitbreaker-gatewayfilter-factory class=anchor aria-hidden=true>#</a></h3><p>Spring Cloud CircuitBreaker GatewayFilter工厂使用Spring Cloud CircuitBreaker APIs将Gateway路由包裹在一个断路器中。Spring Cloud CircuitBreaker支持多个可与Spring Cloud Gateway一起使用的库。Spring Cloud支持Resilience4J开箱即用。</p><p>要启用Spring Cloud CircuitBreaker过滤器，你需要将<code>spring-cloud-starter-circuitbreaker-reactor-resilience4j</code>放在classpath上。下面的例子配置了一个Spring Cloud CircuitBreaker <code>GatewayFilter</code>。</p><p>Example 20. application.yml</p><pre><code class=language-yaml>spring:
  cloud:
    gateway:
      routes:
      - id: circuitbreaker_route
        uri: https://example.org
        filters:
        - CircuitBreaker=myCircuitBreaker
</code></pre><p>要配置断路器，请参阅你所使用的底层断路器实现的配置。</p><ul><li><a href=https://cloud.spring.io/spring-cloud-circuitbreaker/reference/html/spring-cloud-circuitbreaker.html>Resilience4J Documentation</a></li></ul><p>Spring Cloud CircuitBreaker过滤器也可以接受一个可选的<code>fallbackUri</code>参数。目前，只支持<code>forward:</code>模式化的URI。如果回退被调用，请求将被转发到URI所匹配的控制器。下面的例子配置了这样一个fallback。</p><p>Example 21. application.yml</p><pre><code class=language-yaml>spring:
  cloud:
    gateway:
      routes:
      - id: circuitbreaker_route
        uri: lb://backing-service:8088
        predicates:
        - Path=/consumingServiceEndpoint
        filters:
        - name: CircuitBreaker
          args:
            name: myCircuitBreaker
            fallbackUri: forward:/inCaseOfFailureUseThis
        - RewritePath=/consumingServiceEndpoint, /backingServiceEndpoint
</code></pre><p>下面的列表在Java中做同样的事情。</p><p>Example 22. Application.java</p><pre><code class=language-java>@Bean
public RouteLocator routes(RouteLocatorBuilder builder) {
    return builder.routes()
        .route(&quot;circuitbreaker_route&quot;, r -&gt; r.path(&quot;/consumingServiceEndpoint&quot;)
            .filters(f -&gt; f.circuitBreaker(c -&gt; c.name(&quot;myCircuitBreaker&quot;).fallbackUri(&quot;forward:/inCaseOfFailureUseThis&quot;))
                .rewritePath(&quot;/consumingServiceEndpoint&quot;, &quot;/backingServiceEndpoint&quot;)).uri(&quot;lb://backing-service:8088&quot;)
        .build();
}
</code></pre><p>本例在调用断路器回退时转发到<code>/inCaseofFailureUseThis</code> URI。请注意，这个例子还演示了（可选）Spring Cloud LoadBalancer的负载均衡（由目标URI上的<code>lb</code>前缀定义）。</p><p>主要情况是使用<code>fallbackUri</code>来定义网关应用中的内部控制器或处理器。然而，你也可以将请求重新路由到外部应用程序的控制器或处理程序，如下所示。</p><p>Example 23. application.yml</p><pre><code class=language-yaml>spring:
  cloud:
    gateway:
      routes:
      - id: ingredients
        uri: lb://ingredients
        predicates:
        - Path=//ingredients/**
        filters:
        - name: CircuitBreaker
          args:
            name: fetchIngredients
            fallbackUri: forward:/fallback
      - id: ingredients-fallback
        uri: http://localhost:9994
        predicates:
        - Path=/fallback
</code></pre><p>在这个例子中，网关应用程序中没有 <code>fallback</code> 端点或处理程序。然而，在另一个应用程序中有一个，在<code>localhost:9994</code>下注册。</p><p>在请求被转发到回退的情况下，Spring Cloud CircuitBreaker Gateway过滤器也提供了引起该请求的<code>Throwable</code>。它作为 <code>ServerWebExchangeUtils.CIRCUITBREAKER_EXECUTION_EXCEPTION_ATTR</code> 属性被添加到 <code>ServerWebExchange</code> 中，在网关应用程序中处理fallback时可以使用。</p><p>对于外部控制器/处理程序的情况，可以添加带有异常细节的头文件。你可以在<a href=https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#fallback-headers>FallbackHeaders GatewayFilter Factory section</a> 中找到更多关于这样做的信息。</p><h4 id=651-状态码中的断路器熔断>6.5.1. 状态码中的断路器熔断<a href=#651-状态码中的断路器熔断 class=anchor aria-hidden=true>#</a></h4><p>在某些情况下，你可能想根据它所包裹的路由返回的状态代码来熔断。断路器配置对象需要一个状态代码列表，如果返回这些代码将导致断路器熔断。当设置你想让断路器熔断的状态代码时，你可以使用一个带有状态代码值的整数或HttpStatus枚举的字符串表示。</p><p>Example 24. application.yml</p><pre><code class=language-yaml>spring:
  cloud:
    gateway:
      routes:
      - id: circuitbreaker_route
        uri: lb://backing-service:8088
        predicates:
        - Path=/consumingServiceEndpoint
        filters:
        - name: CircuitBreaker
          args:
            name: myCircuitBreaker
            fallbackUri: forward:/inCaseOfFailureUseThis
            statusCodes:
              - 500
              - &quot;NOT_FOUND&quot;
</code></pre><p>Example 25. Application.java</p><pre><code class=language-java>@Bean
public RouteLocator routes(RouteLocatorBuilder builder) {
    return builder.routes()
        .route(&quot;circuitbreaker_route&quot;, r -&gt; r.path(&quot;/consumingServiceEndpoint&quot;)
            .filters(f -&gt; f.circuitBreaker(c -&gt; c.name(&quot;myCircuitBreaker&quot;).fallbackUri(&quot;forward:/inCaseOfFailureUseThis&quot;).addStatusCode(&quot;INTERNAL_SERVER_ERROR&quot;))
                .rewritePath(&quot;/consumingServiceEndpoint&quot;, &quot;/backingServiceEndpoint&quot;)).uri(&quot;lb://backing-service:8088&quot;)
        .build();
}
</code></pre><h3 id=66-the-fallbackheaders-gatewayfilter-factory>6.6. The FallbackHeaders GatewayFilter Factory<a href=#66-the-fallbackheaders-gatewayfilter-factory class=anchor aria-hidden=true>#</a></h3><p>通过<code>FallbackHeaders</code>工厂，你可以在转发到外部应用程序中的<code>fallbackUri</code>的请求的标题中添加<code>Spring Cloud CircuitBreaker</code>的执行异常细节，如以下场景。</p><p>Example 26. application.yml</p><pre><code class=language-yaml>spring:
  cloud:
    gateway:
      routes:
      - id: ingredients
        uri: lb://ingredients
        predicates:
        - Path=//ingredients/**
        filters:
        - name: CircuitBreaker
          args:
            name: fetchIngredients
            fallbackUri: forward:/fallback
      - id: ingredients-fallback
        uri: http://localhost:9994
        predicates:
        - Path=/fallback
        filters:
        - name: FallbackHeaders
          args:
            executionExceptionTypeHeaderName: Test-Header
</code></pre><p>在这个例子中，在运行断路器时发生执行异常后，请求被转发到运行在<code>localhost:9994</code>的应用程序中的<code>fallback</code>端点或处理器。带有异常类型、消息和（如果有）根本原因的异常类型和消息的头文件被<code>FallbackHeaders</code>过滤器添加到该请求中。</p><p>你可以通过设置以下参数的值来覆盖配置中的头文件名称（显示为默认值）。</p><ul><li><code>executionExceptionTypeHeaderName</code> ( <code>"Execution-Exception-Type"</code> )</li><li><code>executionExceptionMessageHeaderName</code> ( <code>"Execution-Exception-Message"</code> )</li><li><code>rootCauseExceptionTypeHeaderName</code> ( <code>"Root-Cause-Exception-Type"</code> )</li><li><code>rootCauseExceptionMessageHeaderName</code> ( <code>"Root-Cause-Exception-Message"</code> )</li></ul><p>关于断路器和网关的更多信息，请参阅<a href=https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#spring-cloud-circuitbreaker-filter-factory>Spring Cloud CircuitBreaker Factory部分</a>。</p><h3 id=67-the-maprequestheader-gatewayfilter-factory>6.7. The MapRequestHeader GatewayFilter Factory<a href=#67-the-maprequestheader-gatewayfilter-factory class=anchor aria-hidden=true>#</a></h3><p>MapRequestHeader GatewayFilter工厂接受fromHeader和toHeader参数。它创建一个新的命名头（toHeader），并从传入的http请求的现有命名头（fromHeader）中提取值。如果输入的头不存在，过滤器没有任何影响。如果新的命名头信息已经存在，它的值就会被增加新的值。下面的例子配置了一个MapRequestHeader。</p><p>Example 27. application.yml</p><pre><code class=language-yaml>spring:
  cloud:
    gateway:
      routes:
      - id: map_request_header_route
        uri: https://example.org
        filters:
        - MapRequestHeader=Blue, X-Request-Red
</code></pre><p>这将在下游请求中添加<code>X-Request-Red:&lt;values></code>头，并从传入的HTTP请求的<code>Blue</code>头中更新数值。</p><h3 id=68-the-prefixpath-gatewayfilter-factory>6.8. The PrefixPath GatewayFilter Factory<a href=#68-the-prefixpath-gatewayfilter-factory class=anchor aria-hidden=true>#</a></h3><p>PrefixPath GatewayFilter工厂需要一个前缀参数。下面的例子配置了一个PrefixPath GatewayFilter。</p><p>Example 28. application.yml</p><pre><code class=language-yaml>spring:
  cloud:
    gateway:
      routes:
      - id: prefixpath_route
        uri: https://example.org
        filters:
        - PrefixPath=/mypath
</code></pre><p>这将把<code>/mypath</code>作为所有匹配请求的路径的前缀。因此，一个到<code>/hello</code>的请求将被发送到<code>/mypath/hello</code>。</p><h3 id=69-the-preservehostheader-gatewayfilter-factory>6.9. The PreserveHostHeader GatewayFilter Factory<a href=#69-the-preservehostheader-gatewayfilter-factory class=anchor aria-hidden=true>#</a></h3><p>PreserveHostHeader GatewayFilter工厂没有参数。这个过滤器设置一个请求属性，路由过滤器会检查该属性，以确定是否应该发送原始的主机头，而不是由HTTP客户端确定的主机头。下面的例子配置了一个PreserveHostHeader GatewayFilter。</p><p>Example 29. application.yml</p><pre><code class=language-yaml>spring:
  cloud:
    gateway:
      routes:
      - id: preserve_host_route
        uri: https://example.org
        filters:
        - PreserveHostHeader
</code></pre><h3 id=610-the-requestratelimiter-gatewayfilter-factory>6.10. The RequestRateLimiter GatewayFilter Factory<a href=#610-the-requestratelimiter-gatewayfilter-factory class=anchor aria-hidden=true>#</a></h3><p><code>RequestRateLimiter``GatewayFilter</code>工厂使用<code>RateLimiter</code>实现来确定是否允许当前请求继续进行。如果不允许，将返回 &ldquo;HTTP 429 - Too Many Requests&rdquo;（默认）的状态。</p><p>这个过滤器需要一个可选的<code>keyResolver</code>参数和特定于速率限制器的参数（在本节后面描述）。</p><p><code>keyResolver</code>是一个实现<code>KeyResolver</code>接口的bean。在配置中，使用SpEL来引用Bean的名字。<code>#{@myKeyResolver}</code>是一个SpEL表达式，它引用了一个名为<code>myKeyResolver</code>的bean。下面的列表显示了<code>KeyResolver</code>的接口。</p><p>Example 30. KeyResolver.java</p><pre><code class=language-java>public interface KeyResolver {
    Mono&lt;String&gt; resolve(ServerWebExchange exchange);
}
</code></pre><p><code>KeyResolver</code>接口让可插拔的策略得出限制请求的密钥。在未来的里程碑版本中，会有一些<code>KeyResolver</code>的实现。</p><p><code>KeyResolver</code>的默认实现是<code>PrincipalNameKeyResolver</code>，它从<code>ServerWebExchange</code>中检索<code>Principal</code>并调用<code>Principal.getName()</code>。</p><p>默认情况下，如果<code>KeyResolver</code>没有找到一个密钥，请求将被拒绝。你可以通过设置<code>spring.cloud.gateway.filter.request-rate-limiter.deny-empty-key</code>（<code>true</code>或<code>false</code>）和<code>spring.cloud.gateway.filter.request-rate-limiter.empty-key-status-code</code>属性调整这种行为。</p><p><code>RequestRateLimiter</code> 不能用 &ldquo;快捷方式&rdquo; 符号来配置。下面的例子是无效的</p><p>Example 31. application.properties</p><pre><code class=language-properties># INVALID SHORTCUT CONFIGURATION
spring.cloud.gateway.routes[0].filters[0]=RequestRateLimiter=2, 2, #{@userkeyresolver}
</code></pre><h4 id=6101-redis-ratelimiter>6.10.1. Redis RateLimiter<a href=#6101-redis-ratelimiter class=anchor aria-hidden=true>#</a></h4><p>Redis的实现是基于<a href=https://stripe.com/blog/rate-limiters>Stripe</a>的工作。它需要使用<code>spring-boot-starter-data-redis-reactive</code> Spring Boot启动器。</p><p>使用的算法是<a href=https://en.wikipedia.org/wiki/Token_bucket>Token Bucket Algorithm</a>。</p><p><code>redis-rate-limiter.replenishRate</code>属性是你希望用户每秒可以做多少个请求，而不允许有任何放弃的请求。这就是代币桶被填充的速度。</p><p><code>redis-rate-limiter.burstCapacity</code>属性是允许一个用户在一秒钟内完成的最大请求数。这是代币桶可以容纳的代币数量。将此值设置为零，可以阻止所有请求。</p><p><code>redis-rate-limiter.requestedTokens</code>属性是一个请求需要花费多少代币。这是每次请求时从桶中取出的代币数量，默认为<code>1</code>。</p><p>稳定的速率是通过在<code>replenishRate</code>和<code>burstCapacity</code>中设置相同的值来完成的。通过设置<code>burstCapacity'高于</code>replenishRate'，可以允许临时的突发。在这种情况下，速率限制器需要在突发之间允许一些时间（根据<code>replenishRate</code>），因为连续两次突发将导致请求被放弃（<code>HTTP 429 - Too Many Requests</code>）。下面的列表配置了一个<code>redis-rate-limiter</code>。</p><p>通过设置 <code>replenishRate</code> 为想要的请求数，<code>requestedTokens</code> 为秒数，<code>burstCapacity</code> 为 <code>replenishRate</code> 和 <code>requestedTokens</code> 的乘积，来实现低于 <code>1 request/s</code> 的速率限制，例如，设置 <code>replenishRate=1</code>，<code>requestedTokens=60</code> 和 <code>burstCapacity=60</code> 将导致限制为 <code>1 request/min</code>。</p><p>Example 32. application.yml</p><pre><code class=language-yaml>spring:
  cloud:
    gateway:
      routes:
      - id: requestratelimiter_route
        uri: https://example.org
        filters:
        - name: RequestRateLimiter
          args:
            redis-rate-limiter.replenishRate: 10
            redis-rate-limiter.burstCapacity: 20
            redis-rate-limiter.requestedTokens: 1
</code></pre><p>下面的例子在Java中配置了一个KeyResolver。</p><p>Example 33. Config.java</p><pre><code class=language-java>@Bean
KeyResolver userKeyResolver() {
    return exchange -&gt; Mono.just(exchange.getRequest().getQueryParams().getFirst(&quot;user&quot;));
}
</code></pre><p>这定义了每个用户的请求率限制为10。爆发20次是允许的，但是，在下一秒，只有10个请求可以使用。<code>KeyResolver</code> 是一个简单的，获得 <code>user</code> 请求参数（注意，不建议在生产中这样做）。</p><p>你也可以把速率限制器定义为一个实现<code>RateLimiter</code>接口的bean。在配置中，你可以用SpEL来引用bean的名字。<code>#{@myRateLimiter}</code>是一个SpEL表达式，引用一个名为<code>myRateLimiter</code>的bean。下面的列表定义了一个速率限制器，它使用了前面列表中定义的<code>KeyResolver</code>。</p><p>Example 34. application.yml</p><pre><code class=language-yaml>spring:
  cloud:
    gateway:
      routes:
      - id: requestratelimiter_route
        uri: https://example.org
        filters:
        - name: RequestRateLimiter
          args:
            rate-limiter: &quot;#{@myRateLimiter}&quot;
            key-resolver: &quot;#{@userKeyResolver}&quot;
</code></pre><h3 id=611-the-redirectto-gatewayfilter-factory>6.11. The RedirectTo GatewayFilter Factory<a href=#611-the-redirectto-gatewayfilter-factory class=anchor aria-hidden=true>#</a></h3><p><code>RedirectTo</code> <code>GatewayFilter</code>工厂需要两个参数，<code>status</code>和<code>url</code>。<code>status</code>参数应该是一个300系列的重定向HTTP代码，如301。<code>url</code>参数应该是一个有效的URL。这是<code>Location</code>头的值。对于相对重定向，你应该使用<code>uri: no://op</code>作为路由定义的URI。下面的列表配置了一个<code>RedirectTo</code> <code>GatewayFilter</code>。</p><p>Example 35. application.yml</p><pre><code class=language-yaml>spring:
  cloud:
    gateway:
      routes:
      - id: prefixpath_route
        uri: https://example.org
        filters:
        - RedirectTo=302, https://acme.org
</code></pre><p>这将发送一个带有<code>Location:https://acme.org</code>头的状态302来执行重定向。</p><h3 id=612-the-removerequestheader-gatewayfilter-factory>6.12. The RemoveRequestHeader GatewayFilter Factory<a href=#612-the-removerequestheader-gatewayfilter-factory class=anchor aria-hidden=true>#</a></h3><p>RemoveRequestHeader GatewayFilter工厂需要一个name参数。它是要删除的头的名称。下面的列表配置了一个RemoveRequestHeader GatewayFilter。</p><p>Example 36. application.yml</p><pre><code class=language-yaml>spring:
  cloud:
    gateway:
      routes:
      - id: removerequestheader_route
        uri: https://example.org
        filters:
        - RemoveRequestHeader=X-Request-Foo
</code></pre><p>这在向下游发送之前删除了<code>X-Request-Foo</code>标头。</p><h3 id=613-removeresponseheader-gatewayfilter-factory>6.13. RemoveResponseHeader GatewayFilter Factory<a href=#613-removeresponseheader-gatewayfilter-factory class=anchor aria-hidden=true>#</a></h3><p>RemoveResponseHeader GatewayFilter工厂需要一个name参数。它是要删除的头的名称。下面的列表配置了一个RemoveResponseHeader GatewayFilter。</p><p>Example 37. application.yml</p><pre><code class=language-yaml>spring:
  cloud:
    gateway:
      routes:
      - id: removeresponseheader_route
        uri: https://example.org
        filters:
        - RemoveResponseHeader=X-Response-Foo
</code></pre><p>他将在响应返回到网关客户端之前从响应中删除<code>X-Response-Foo</code>头。</p><p>要删除任何种类的敏感头，你应该为任何你可能想这样做的路由配置这个过滤器。此外，你可以通过使用<code>spring.cloud.gateway.default-filters</code>来配置一次这个过滤器，并让它应用于所有路由。</p><h3 id=614-the-removerequestparameter-gatewayfilter-factory>6.14. The RemoveRequestParameter GatewayFilter Factory<a href=#614-the-removerequestparameter-gatewayfilter-factory class=anchor aria-hidden=true>#</a></h3><p>RemoveRequestParameter GatewayFilter工厂需要一个名称参数。它是要删除的查询参数的名称。下面的例子配置了一个RemoveRequestParameter GatewayFilter。</p><p>Example 38. application.yml</p><pre><code class=language-yaml>spring:
  cloud:
    gateway:
      routes:
      - id: removerequestparameter_route
        uri: https://example.org
        filters:
        - RemoveRequestParameter=red
</code></pre><p>这将在向下游发送之前删除<code>red</code>参数。</p><h3 id=615-the-rewritepath-gatewayfilter-factory>6.15. The RewritePath GatewayFilter Factory<a href=#615-the-rewritepath-gatewayfilter-factory class=anchor aria-hidden=true>#</a></h3><p><code>RewritePath</code> <code>GatewayFilter</code>工厂接收一个路径<code>regexp</code>参数和一个<code>replacement</code>参数。这是用Java正则表达式来重写请求路径的一种灵活方式。下面的列表配置了一个<code>RewritePath</code> <code>GatewayFilter</code>。</p><p>Example 39. application.yml</p><pre><code class=language-yaml>spring:
  cloud:
    gateway:
      routes:
      - id: rewritepath_route
        uri: https://example.org
        predicates:
        - Path=/red/**
        filters:
        - RewritePath=/red/?(?&lt;segment&gt;.*), /$\{segment}
</code></pre><p>对于一个<code>/red/blue</code>的请求路径，在进行下游请求之前将路径设置为<code>/blue</code>。注意，由于YAML规范，<code>$</code>应该被替换成<code>$\</code>。</p><h3 id=616-rewritelocationresponseheader-gatewayfilter-factory>6.16. RewriteLocationResponseHeader GatewayFilter Factory<a href=#616-rewritelocationresponseheader-gatewayfilter-factory class=anchor aria-hidden=true>#</a></h3><p>RewriteLocationResponseHeader GatewayFilter工厂修改Location响应头的值，通常是为了去掉后台的特定细节。它需要 <code>stripVersionMode</code>、<code>locationHeaderName</code>、<code>hostValue</code> 和 <code>protocolsRegex</code> 参数。下面的列表配置了一个RewriteLocationResponseHeader GatewayFilter。</p><p>Example 40. application.yml</p><pre><code class=language-yaml>spring:
  cloud:
    gateway:
      routes:
      - id: rewritelocationresponseheader_route
        uri: http://example.org
        filters:
        - RewriteLocationResponseHeader=AS_IN_REQUEST, Location, ,
</code></pre><p>例如，对于一个<code>POST api.example.com/some/object/name</code>的请求，<code>Location</code>的响应头值<code>object-service.prod.example.net/v2/some/object/id</code>被改写为<code>api.example.com/some/object/id</code>。</p><p><code>stripVersionMode</code>参数有以下可能的值。<code>NEVER_STRIP</code>, <code>AS_IN_REQUEST</code> (默认), 和 <code>ALWAYS_STRIP</code> 。</p><ul><li><code>NEVER_STRIP</code> : 即使原始请求路径不包含版本，版本也不会被剥离。</li><li><code>AS_IN_REQUEST</code> 只有在原始请求路径不包含版本的情况下，版本才会被剥离。</li><li><code>ALWAYS_STRIP</code> 即使原始请求路径包含版本，版本也会被剥离。</li></ul><p><code>hostValue</code>参数，如果提供的话，用于替换响应<code>Location</code>头的<code>host:port</code>部分。如果没有提供，则使用<code>Host</code>请求头的值。</p><p>参数 <code>protocolsRegex</code> 必须是一个有效的正则 <code>String</code>，与协议名称相匹配。如果没有匹配，过滤器不做任何事情。默认是<code>http|https|ftp|ftps</code>。</p><h3 id=617-the-rewriteresponseheader-gatewayfilter-factory>6.17. The RewriteResponseHeader GatewayFilter Factory<a href=#617-the-rewriteresponseheader-gatewayfilter-factory class=anchor aria-hidden=true>#</a></h3><p>RewriteResponseHeader GatewayFilter工厂接受名称、regexp和替换参数。它使用Java正则表达式，以一种灵活的方式重写响应头的值。下面的例子配置了一个RewriteResponseHeader GatewayFilter。</p><p>Example 41. application.yml</p><pre><code class=language-yaml>spring:
  cloud:
    gateway:
      routes:
      - id: rewriteresponseheader_route
        uri: https://example.org
        filters:
        - RewriteResponseHeader=X-Response-Red, , password=[^&amp;]+, password=***
</code></pre><p>对于一个头值为<code>/42?user=ford&password=omg!what&flag=true</code>，它在发出下游请求后被设置为<code>/42?user=ford&password=***&flag=true</code>。由于YAML的规范，你必须用<code>$\</code>来表示<code>$</code>。</p><h3 id=618-the-savesession-gatewayfilter-factory>6.18. The SaveSession GatewayFilter Factory<a href=#618-the-savesession-gatewayfilter-factory class=anchor aria-hidden=true>#</a></h3><p>SaveSession GatewayFilter工厂在转发下游调用之前强制进行<code>WebSession::save</code>操作。这在使用类似<code>Spring Session</code>的懒惰数据存储时特别有用，因为你需要确保在进行转发调用之前已经保存了会话状态。下面的例子配置了一个SaveSession GatewayFilter。</p><p>Example 42. application.yml</p><pre><code class=language-yaml>spring:
  cloud:
    gateway:
      routes:
      - id: save_session
        uri: https://example.org
        predicates:
        - Path=/foo/**
        filters:
        - SaveSession
</code></pre><p>如果你将<a href=https://projects.spring.io/spring-security/>Spring Security</a>与Spring Session集成，并希望确保安全细节已被转发给远程进程，这一点至关重要。</p><h3 id=619-the-secureheaders-gatewayfilter-factory>6.19. The SecureHeaders GatewayFilter Factory<a href=#619-the-secureheaders-gatewayfilter-factory class=anchor aria-hidden=true>#</a></h3><p><code>SecureHeaders</code> <code>GatewayFilter</code>工厂根据<a href=https://blog.appcanary.com/2017/http-security-headers.html>本博文</a>的建议，在响应中添加了一些头信息。</p><p>添加了以下标题（显示的是其默认值）。</p><ul><li><code>X-Xss-Protection:1 (mode=block</code> )</li><li><code>Strict-Transport-Security (max-age=631138519</code> )</li><li><code>X-Frame-Options (DENY)</code></li><li><code>X-Content-Type-Options (nosniff)</code></li><li><code>Referrer-Policy (no-referrer)</code></li><li><code>Content-Security-Policy (default-src 'self' https:; font-src 'self' https: data:; img-src 'self' https: data:; object-src 'none'; script-src https:; style-src 'self' https: 'unsafe-inline)'</code></li><li><code>X-Download-Options (noopen)</code></li><li><code>X-Permitted-Cross-Domain-Policies (none)</code></li></ul><p>要改变默认值，请在<code>spring.cloud.gateway.filter.secure-headers</code>命名空间中设置相应的属性。以下属性是可用的。</p><ul><li><code>xss-protection-header</code></li><li><code>strict-transport-security</code></li><li><code>x-frame-options</code></li><li><code>x-content-type-options</code></li><li><code>referrer-policy</code></li><li><code>content-security-policy</code></li><li><code>x-download-options</code></li><li><code>x-permitted-cross-domain-policies</code></li></ul><p>要禁用默认值，请用逗号分隔的值设置<code>spring.cloud.gateway.filter.secure-headers.disable</code>属性。下面的例子显示了如何做到这一点。</p><pre><code class=language-properties>spring.cloud.gateway.filter.secure-headers.disable=x-frame-options,strict-transport-security
</code></pre><blockquote><p>需要使用安全头的小写全名来禁用它。</p></blockquote><h3 id=620-the-setpath-gatewayfilter-factory>6.20. The SetPath GatewayFilter Factory<a href=#620-the-setpath-gatewayfilter-factory class=anchor aria-hidden=true>#</a></h3><p>SetPath GatewayFilter工厂接受一个路径模板参数。它提供了一种简单的方法，通过允许模板化的路径段来操作请求路径。这使用了Spring Framework的URI模板。允许多个匹配段。下面的例子配置了一个SetPath GatewayFilter。</p><p>Example 43. application.yml</p><pre><code class=language-yaml>spring:
  cloud:
    gateway:
      routes:
      - id: setpath_route
        uri: https://example.org
        predicates:
        - Path=/red/{segment}
        filters:
        - SetPath=/{segment}
</code></pre><p>对于请求路径为<code>/red/blue</code>的情况，在进行下游请求前将路径设置为<code>/blue</code>。</p><h3 id=621-the-setrequestheader-gatewayfilter-factory>6.21. The SetRequestHeader GatewayFilter Factory<a href=#621-the-setrequestheader-gatewayfilter-factory class=anchor aria-hidden=true>#</a></h3><p>SetRequestHeader GatewayFilter工厂接受name和value参数。下面的列表配置了一个SetRequestHeader GatewayFilter。</p><p>Example 44. application.yml</p><pre><code class=language-yaml>spring:
  cloud:
    gateway:
      routes:
      - id: setrequestheader_route
        uri: https://example.org
        filters:
        - SetRequestHeader=X-Request-Red, Blue
</code></pre><p>这个<code>GatewayFilter</code>替换（而不是添加）所有给定名称的头信息。因此，如果下游服务器响应的是<code>X-Request-Red:1234</code>，这将被替换为<code>X-Request-Red:Blue</code>，这就是下游服务将收到的内容。</p><p><code>SetRequestHeader</code>知道用于匹配路径或主机的URI变量。URI变量可以在值中使用，并在运行时被扩展。下面的例子配置了一个使用变量的<code>SetRequestHeader``GatewayFilter</code>。</p><p>Example 45. application.yml</p><pre><code class=language-yaml>spring:
  cloud:
    gateway:
      routes:
      - id: setrequestheader_route
        uri: https://example.org
        predicates:
        - Host: {segment}.myhost.org
        filters:
        - SetRequestHeader=foo, bar-{segment}
</code></pre><h3 id=622-the-setresponseheader-gatewayfilter-factory>6.22. The SetResponseHeader GatewayFilter Factory<a href=#622-the-setresponseheader-gatewayfilter-factory class=anchor aria-hidden=true>#</a></h3><p><code>SetResponseHeader</code> <code>GatewayFilter</code>工厂接受<code>name</code>和<code>value</code>参数。下面的列表配置了一个<code>SetResponseHeader</code> <code>GatewayFilter</code>。</p><p>Example 46. application.yml</p><pre><code class=language-yaml>spring:
  cloud:
    gateway:
      routes:
      - id: setresponseheader_route
        uri: https://example.org
        filters:
        - SetResponseHeader=X-Response-Red, Blue
</code></pre><p>这个GatewayFilter会替换（而不是添加）所有给定名称的头信息。因此，如果下游服务器响应的是<code>X-Response-Red:1234</code>，这将被替换为<code>X-Response-Red:Blue</code>，这就是网关客户端将收到的内容。</p><p><code>SetResponseHeader</code>知道用于匹配路径或主机的URI变量。URI变量可以在值中使用，并将在运行时被扩展。下面的例子配置了一个<code>SetResponseHeader``GatewayFilter</code>，使用了一个变量。</p><p>Example 47. application.yml</p><pre><code class=language-yaml>spring:
  cloud:
    gateway:
      routes:
      - id: setresponseheader_route
        uri: https://example.org
        predicates:
        - Host: {segment}.myhost.org
        filters:
        - SetResponseHeader=foo, bar-{segment}
</code></pre><h3 id=623-the-setstatus-gatewayfilter-factory>6.23. The SetStatus GatewayFilter Factory<a href=#623-the-setstatus-gatewayfilter-factory class=anchor aria-hidden=true>#</a></h3><p>SetStatus GatewayFilter工厂只接受一个参数，即status。它必须是一个有效的Spring HttpStatus。它可以是<code>404</code>的整数值或枚举的字符串表示。<code>NOT_FOUND</code>。下面的列表配置了一个SetStatus GatewayFilter。</p><p>Example 48. application.yml</p><pre><code class=language-yaml>spring:
  cloud:
    gateway:
      routes:
      - id: setstatusstring_route
        uri: https://example.org
        filters:
        - SetStatus=BAD_REQUEST
      - id: setstatusint_route
        uri: https://example.org
        filters:
        - SetStatus=401
</code></pre><p>在这两种情况下，响应的HTTP状态被设置为401。</p><p>你可以配置<code>SetStatus</code> <code>GatewayFilter</code>，在响应中的一个头中返回代理请求的原始HTTP状态代码。如果配置了以下属性，该头会被添加到响应中。</p><p>Example 49. application.yml</p><pre><code class=language-yaml>spring:
  cloud:
    gateway:
      set-status:
        original-status-header-name: original-http-status
</code></pre><h3 id=624-the-stripprefix-gatewayfilter-factory>6.24. The StripPrefix GatewayFilter Factory<a href=#624-the-stripprefix-gatewayfilter-factory class=anchor aria-hidden=true>#</a></h3><p>StripPrefix GatewayFilter工厂需要一个参数，即parts。parts参数表示在向下游发送请求之前要从路径中剥离的部分的数量。下面的列表配置了一个StripPrefix GatewayFilter。</p><p>Example 50. application.yml</p><pre><code class=language-yaml>spring:
  cloud:
    gateway:
      routes:
      - id: nameRoot
        uri: https://nameservice
        predicates:
        - Path=/name/**
        filters:
        - StripPrefix=2
</code></pre><p>当通过网关向<code>/name/blue/red</code>发出请求时，向<code>nameservice</code>发出的请求看起来像<code>nameservice/red</code>。</p><h3 id=625-the-retry-gatewayfilter-factory>6.25. The Retry GatewayFilter Factory<a href=#625-the-retry-gatewayfilter-factory class=anchor aria-hidden=true>#</a></h3><p><code>Retry</code> <code>GatewayFilter</code>工厂支持以下参数。</p><ul><li><code>retries</code> : 应该尝试的重试次数。</li><li><code>statuses</code> : 应该重试的HTTP状态代码，用<code>org.springframework.http.HttpStatus</code>表示。</li><li><code>methods</code>：应该重试的HTTP方法，用<code>org.springframework.http.HttpMethod</code>表示。</li><li><code>series</code>：要重试的状态代码系列，用<code>org.springframework.http.HttpStatus.Series</code>表示。</li><li><code>exceptions</code> : 抛出的异常列表，应该被重新尝试。</li><li><code>backoff</code>：为重试配置的指数后验。重试的时间间隔为<code>firstBackoff * (factor ^ n)</code>，其中<code>n</code>是迭代次数。如果配置了 &ldquo;maxBackoff&rdquo;，应用的最大后退时间限制为 <code>maxBackoff</code>。如果<code>basedOnPreviousValue</code>为真，后退是通过<code>prevBackoff * factor</code>计算的。</li></ul><p>如果启用了 <code>Retry</code> 过滤器，下列默认值被配置。</p><ul><li><code>retries</code> : Three times</li><li><code>series</code> : 5XX series</li><li><code>methods</code> : GET method</li><li><code>exceptions</code> : <code>IOException</code> and <code>TimeoutException</code></li><li><code>backoff</code> : disabled</li></ul><p>下面的列表配置了一个重试的<code>GatewayFilter</code>。</p><p>Example 51. application.yml</p><pre><code class=language-yaml>spring:
  cloud:
    gateway:
      routes:
      - id: retry_test
        uri: http://localhost:8080/flakey
        predicates:
        - Host=*.retry.com
        filters:
        - name: Retry
          args:
            retries: 3
            statuses: BAD_GATEWAY
            methods: GET,POST
            backoff:
              firstBackoff: 10ms
              maxBackoff: 50ms
              factor: 2
              basedOnPreviousValue: false
</code></pre><blockquote><p>当使用带有<code>forward:</code>前缀的URL的重试过滤器时，应仔细编写目标端点，以便在出现错误时，它不会做任何可能导致响应被发送到客户端并提交的事情。例如，如果目标端点是一个有注释的控制器，目标控制器方法不应该返回<code>ResponseEntity</code>，并带有错误状态代码。相反，它应该抛出一个<code>Exception</code>或发出一个错误信号（例如，通过<code>Mono.error(ex)</code>返回值），重试过滤器可以被配置为通过重试来处理。</p></blockquote><blockquote><p>当对任何带有请求体的HTTP方法使用重试过滤器时，请求体将被缓存，网关将变得内存有限。请求体被缓存在一个由<code>ServerWebExchangeUtils.CACHED_REQUEST_BODY_ATTR</code>定义的请求属性中。该对象的类型是<code>org.springframework.core.io.buffer.DataBuffer</code>。</p></blockquote><h3 id=626-the-requestsize-gatewayfilter-factory>6.26. The RequestSize GatewayFilter Factory<a href=#626-the-requestsize-gatewayfilter-factory class=anchor aria-hidden=true>#</a></h3><p>当请求的大小超过允许的限制时，<code>RequestSize</code> <code>GatewayFilter</code>工厂可以限制请求到达下游服务。该过滤器需要一个<code>maxSize</code>参数。<code>maxSize</code>是一个<code>DataSize</code>类型，所以值可以定义为一个数字，后面有一个可选的<code>DataUnit</code>后缀，如<code>KB</code>或<code>MB</code>。默认值是<code>B</code>，表示字节数。它是以字节为单位定义的请求的可允许的大小限制。下面的列表配置了一个<code>RequestSize</code> <code>GatewayFilter</code>。</p><p>Example 52. application.yml</p><pre><code class=language-yaml>spring:
  cloud:
    gateway:
      routes:
      - id: request_size_route
        uri: http://localhost:8080/upload
        predicates:
        - Path=/upload
        filters:
        - name: RequestSize
          args:
            maxSize: 5000000
</code></pre><p>RequestSize GatewayFilter工厂将响应状态设置为413 Payload Too Large，当请求由于大小而被拒绝时，会有一个额外的头 errorMessage。下面的例子显示了这样一个errorMessage。</p><pre><code class=language-text>errorMessage` : `Request size is larger than permissible limit. Request size is 6.0 MB where permissible limit is 5.0 MB
</code></pre><blockquote><p>如果在路由定义中没有提供过滤参数，默认请求大小被设置为5MB。</p></blockquote><h3 id=627-the-setrequesthostheader-gatewayfilter-factory>6.27. The SetRequestHostHeader GatewayFilter Factory<a href=#627-the-setrequesthostheader-gatewayfilter-factory class=anchor aria-hidden=true>#</a></h3><p>在某些情况下，host header可能需要被重写。在这种情况下，SetRequestHostHeader GatewayFilter工厂可以将现有的host header替换成指定的vaue。该过滤器需要一个<code>host</code>参数。下面的列表配置了一个SetRequestHostHeader GatewayFilter。</p><p>Example 53. application.yml</p><pre><code class=language-yaml>spring:
  cloud:
    gateway:
      routes:
      - id: set_request_host_header_route
        uri: http://localhost:8080/headers
        predicates:
        - Path=/headers
        filters:
        - name: SetRequestHostHeader
          args:
            host: example.org
</code></pre><p><code>SetRequestHostHeader</code> <code>GatewayFilter</code>工厂将主机头的值替换为<code>example.org</code>。</p><h3 id=628-modify-a-request-body-gatewayfilter-factory>6.28. Modify a Request Body GatewayFilter Factory<a href=#628-modify-a-request-body-gatewayfilter-factory class=anchor aria-hidden=true>#</a></h3><p>你可以使用ModifyRequestBody过滤器，在网关向下游发送请求体之前对其进行修改。</p><blockquote><p>这个过滤器只能通过使用Java DSL来配置。</p></blockquote><p>下面的列表显示了如何修改一个请求体GatewayFilter。</p><pre><code class=language-java>@Bean
public RouteLocator routes(RouteLocatorBuilder builder) {
    return builder.routes()
        .route(&quot;rewrite_request_obj&quot;, r -&gt; r.host(&quot;*.rewriterequestobj.org&quot;)
            .filters(f -&gt; f.prefixPath(&quot;/httpbin&quot;)
                .modifyRequestBody(String.class, Hello.class, MediaType.APPLICATION_JSON_VALUE,
                    (exchange, s) -&gt; return Mono.just(new Hello(s.toUpperCase())))).uri(uri))
        .build();
}

static class Hello {
    String message;

    public Hello() { }

    public Hello(String message) {
        this.message = message;
    }

    public String getMessage() {
        return message;
    }

    public void setMessage(String message) {
        this.message = message;
    }
}
</code></pre><blockquote><p>如果请求没有正文，<code>RewriteFilter</code>将被传递为空。应该返回<code>Mono.empty()</code>来指定请求中缺少的主体。</p></blockquote><h3 id=629-modify-a-response-body-gatewayfilter-factory>6.29. Modify a Response Body GatewayFilter Factory<a href=#629-modify-a-response-body-gatewayfilter-factory class=anchor aria-hidden=true>#</a></h3><p>你可以使用ModifyResponseBody过滤器来修改响应体，然后再把它送回给客户端。</p><blockquote><p>这个过滤器只能通过使用Java DSL来配置。</p></blockquote><p>下面的列表显示了如何修改一个响应体GatewayFilter。</p><pre><code class=language-java>@Bean
public RouteLocator routes(RouteLocatorBuilder builder) {
    return builder.routes()
        .route(&quot;rewrite_response_upper&quot;, r -&gt; r.host(&quot;*.rewriteresponseupper.org&quot;)
            .filters(f -&gt; f.prefixPath(&quot;/httpbin&quot;)
                .modifyResponseBody(String.class, String.class,
                    (exchange, s) -&gt; Mono.just(s.toUpperCase()))).uri(uri))
        .build();
}
</code></pre><blockquote><p>如果响应没有正文，<code>RewriteFilter</code>将被传递为空。应该返回<code>Mono.empty()</code>来指定响应中缺少的主体。</p></blockquote><h3 id=630-token-relay-gatewayfilter-factory>6.30. Token Relay GatewayFilter Factory<a href=#630-token-relay-gatewayfilter-factory class=anchor aria-hidden=true>#</a></h3><p>Token Relay是指OAuth2消费者作为客户端，将传入的令牌转发给传出的资源请求。消费者可以是一个纯粹的客户端（如SSO应用程序）或一个资源服务器。</p><p>Spring Cloud Gateway可以将OAuth2访问令牌转发到它所代理的服务的下游。要在网关中添加这个功能，你需要像这样添加TokenRelayGatewayFilterFactory。</p><p>App.java</p><pre><code class=language-java>@Bean
public RouteLocator customRouteLocator(RouteLocatorBuilder builder) {
    return builder.routes()
            .route(&quot;resource&quot;, r -&gt; r.path(&quot;/resource&quot;)
                    .filters(f -&gt; f.tokenRelay())
                    .uri(&quot;http://localhost:9000&quot;))
            .build();
}
</code></pre><p>或者这样</p><p>application.yaml</p><pre><code class=language-yaml>spring:
  cloud:
    gateway:
      routes:
      - id: resource
        uri: http://localhost:9000
        predicates:
        - Path=/resource
        filters:
        - TokenRelay=
</code></pre><p>它将（除了登录用户和抓取令牌外）把认证令牌传递给下游的服务（在这里是<code>/resource</code>）。</p><p>要为Spring Cloud Gateway启用这个功能，需要添加以下依赖项</p><ul><li><code>org.springframework.boot:spring-boot-starter-oauth2-client</code>。</li></ul><p>它是如何工作的？{githubmaster}/src/main/java/org/springframework/cloud/gateway/security/TokenRelayGatewayFilterFactory.java[filter]从当前认证的用户中提取访问令牌，并将其放入下游请求的请求头。</p><p>完整的工作样本见<a href=https://github.com/spring-cloud-samples/sample-gateway-oauth2login>该项目</a></p><blockquote><p>只有当适当的<code>spring.security.oauth2.client.*</code>属性被设置时，TokenRelayGatewayFilterFactory Bean才会被创建，这将触发<code>ReactiveClientRegistrationRepository</code> Bean的创建。</p></blockquote><blockquote><p><code>TokenRelayGatewayFilterFactory</code>使用的<code>ReactiveOAuth2AuthorizedClientService</code>的默认实现使用了一个内存数据存储。如果你需要一个更强大的解决方案，你将需要提供你自己的实现<code>ReactiveOAuth2AuthorizedClientService</code>。</p></blockquote><h3 id=631-default-filters>6.31. Default Filters<a href=#631-default-filters class=anchor aria-hidden=true>#</a></h3><p>要添加一个过滤器并将其应用于所有路由，可以使用 <code>spring.cloud.gateway.default-filters</code>。这个属性需要一个过滤器的列表。下面的列表定义了一组默认过滤器。</p><p>Example 54. application.yml</p><pre><code class=language-yaml>spring:
  cloud:
    gateway:
      default-filters:
      - AddResponseHeader=X-Response-Default-Red, Default-Blue
      - PrefixPath=/httpbin
</code></pre><h2 id=7-global-filters>7. Global Filters<a href=#7-global-filters class=anchor aria-hidden=true>#</a></h2><p>GlobalFilter接口的签名与GatewayFilter相同。这些是特殊的过滤器，有条件地应用于所有路由。</p><blockquote><p>这个接口和它的用法在未来的里程碑版本中可能会有变化。</p></blockquote><h3 id=71-combined-global-filter-and-gatewayfilter-ordering>7.1. Combined Global Filter and GatewayFilter Ordering<a href=#71-combined-global-filter-and-gatewayfilter-ordering class=anchor aria-hidden=true>#</a></h3><p>当一个请求与路由匹配时，过滤网络处理器将<code>GlobalFilter</code>的所有实例和<code>GatewayFilter</code>的所有路由特定实例添加到一个过滤链中。这个组合的过滤器链由<code>org.springframework.core.Ordered</code>接口进行排序，你可以通过实现<code>getOrder()</code>方法来设置这个接口。</p><p>由于Spring Cloud Gateway区分了过滤器逻辑执行的 &ldquo;pre"和 &ldquo;post"阶段（见如何工作），优先级最高的过滤器在 &ldquo;pre"阶段是第一个，在 &ldquo;post"阶段是最后一个。</p><p>下面的列表配置了一个过滤器链。</p><p>Example 55. ExampleConfiguration.java</p><pre><code class=language-java>@Bean
public GlobalFilter customFilter() {
    return new CustomGlobalFilter();
}

public class CustomGlobalFilter implements GlobalFilter, Ordered {

    @Override
    public Mono&lt;Void&gt; filter(ServerWebExchange exchange, GatewayFilterChain chain) {
        log.info(&quot;custom global filter&quot;);
        return chain.filter(exchange);
    }

    @Override
    public int getOrder() {
        return -1;
    }
}
</code></pre><h3 id=72-forward-routing-filter>7.2. Forward Routing Filter<a href=#72-forward-routing-filter class=anchor aria-hidden=true>#</a></h3><p><code>ForwardRoutingFilter</code>在exchange attribute <code>ServerWebExchangeUtils.GATEWAY_REQUEST_URL_ATTR</code>中寻找一个URI。如果URL有一个<code>forward</code>方案（如<code>forward:///localendpoint</code>），它将使用Spring的<code>DispatcherHandler</code>来处理请求。请求URL的路径部分被转发URL中的路径所覆盖。未修改的原始URL被附加到<code>ServerWebExchangeUtils.GATEWAY_ORIGINAL_REQUEST_URL_ATTR</code>属性的列表中。</p><h3 id=73-the-reactiveloadbalancerclientfilter>7.3. The ReactiveLoadBalancerClientFilter<a href=#73-the-reactiveloadbalancerclientfilter class=anchor aria-hidden=true>#</a></h3><p><code>ReactiveLoadBalancerClientFilter</code>在名为<code>ServerWebExchangeUtils.GATEWAY_REQUEST_URL_ATTR</code>的交换属性中寻找一个URI。如果URL有一个<code>lb</code>方案（如<code>lb://myservice</code>），它使用Spring Cloud的<code>ReactorLoadBalancer</code>将名称（本例中的<code>myservice</code>）解析为实际的主机和端口，并替换同一属性中的URI。未修改的原始URL被追加到<code>ServerWebExchangeUtils.GATEWAY_ORIGINAL_REQUEST_URL_ATTR</code>属性的列表中。过滤器也会查看<code>ServerWebExchangeUtils.GATEWAY_SCHEME_PREFIX_ATTR</code>属性，看它是否等于<code>lb</code>。如果是的话，同样的规则也适用。下面的列表配置了一个<code>ReactiveLoadBalancerClientFilter</code>。</p><p>Example 56. application.yml</p><pre><code class=language-yaml>spring:
  cloud:
    gateway:
      routes:
      - id: myRoute
        uri: lb://service
        predicates:
        - Path=/service/**
</code></pre><blockquote><p>默认情况下，当服务实例不能被<code>ReactorLoadBalancer</code>找到时，会返回<code>503</code>。你可以通过设置<code>spring.cloud.gateway.loadbalancer.use404=true</code>将网关配置为返回<code>404</code>。</p></blockquote><blockquote><p>从<code>ReactiveLoadBalancerClientFilter</code>返回的<code>ServiceInstance</code>的<code>isSecure</code>值覆盖了向网关发出的请求中指定的方案。例如，如果请求通过HTTPS进入Gateway，但<code>ServiceInstance</code>表明它不安全，那么下游请求将通过HTTP进行。相反的情况也可以适用。然而，如果在网关配置中为路由指定了 <code>GATEWAY_SCHEME_PREFIX_ATTR</code>，那么前缀将被剥离，来自路由 URL 的结果方案将覆盖 <code>ServiceInstance</code> 的配置。</p></blockquote><blockquote><p>Gateway支持所有的LoadBalancer功能。你可以在<a href=https://docs.spring.io/spring-cloud-commons/docs/current/reference/html/#spring-cloud-loadbalancer>Spring Cloud Commons documentation</a>中阅读更多关于它们的信息。</p></blockquote><h3 id=74-the-netty-routing-filter>7.4. The Netty Routing Filter<a href=#74-the-netty-routing-filter class=anchor aria-hidden=true>#</a></h3><p>如果位于<code>ServerWebExchangeUtils.GATEWAY_REQUEST_URL_ATTR</code> exchange attribute 中的URL有一个http或https方案，Netty路由过滤器就会运行。它使用Netty HttpClient来进行下游代理请求。响应被放在<code>ServerWebExchangeUtils.CLIENT_RESPONSE_ATTR</code> exchange attribute中，供以后的过滤器使用。(还有一个实验性的WebClientHttpRoutingFilter，执行同样的功能，但不需要Netty。)</p><h3 id=75-the-netty-write-response-filter>7.5. The Netty Write Response Filter<a href=#75-the-netty-write-response-filter class=anchor aria-hidden=true>#</a></h3><p>如果在<code>ServerWebExchangeUtils.CLIENT_RESPONSE_ATTR</code> exchange attribute中有一个Netty HttpClientResponse，NettyWriteResponseFilter就会运行。它在所有其他过滤器完成后运行，并将代理响应写回网关客户端响应。(还有一个实验性的WebClientWriteResponseFilter，执行同样的功能，但不需要Netty。)</p><h3 id=76-the-routetorequesturl-filter>7.6. The RouteToRequestUrl Filter<a href=#76-the-routetorequesturl-filter class=anchor aria-hidden=true>#</a></h3><p>如果在<code>ServerWebExchangeUtils.GATEWAY_ROUTE_ATTR</code> exchange attribute中有一个Route对象，RouteToRequestUrlFilter会运行。它创建了一个新的URI，基于请求URI，但用路由对象的URI属性进行更新。新的URI被放置在<code>ServerWebExchangeUtils.GATEWAY_REQUEST_URL_ATTR</code> exchange attribute`中。</p><p>如果URI有一个方案前缀，如<code>lb:ws://serviceid</code>，lb方案将从URI中剥离，并放在<code>ServerWebExchangeUtils.GATEWAY_SCHEME_PREFIX_ATTR</code>中，以便以后在过滤器链中使用。</p><h3 id=77-the-websocket-routing-filter>7.7. The Websocket Routing Filter<a href=#77-the-websocket-routing-filter class=anchor aria-hidden=true>#</a></h3><p>如果位于<code>ServerWebExchangeUtils.GATEWAY_REQUEST_URL_ATTR</code> exchange attribute中的URL有ws或wss方案，则运行websocket路由过滤器。它使用Spring WebSocket基础设施来转发下游的websocket请求。</p><p>你可以通过在URI前加上lb，如<code>lb:ws://serviceid</code>，来平衡websocket的负载。</p><blockquote><p>如果你使用<a href=https://github.com/sockjs>SockJS</a>作为普通HTTP的后备方案，你应该配置一个普通的HTTP路由以及websocket路由。</p></blockquote><p>下面的列表配置了一个websocket路由过滤器。</p><p>Example 57. application.yml</p><pre><code class=language-yaml>spring:
  cloud:
    gateway:
      routes:
      # SockJS route
      - id: websocket_sockjs_route
        uri: http://localhost:3001
        predicates:
        - Path=/websocket/info/**
      # Normal Websocket route
      - id: websocket_route
        uri: ws://localhost:3001
        predicates:
        - Path=/websocket/**
</code></pre><h3 id=78-the-gateway-metrics-filter>7.8. The Gateway Metrics Filter<a href=#78-the-gateway-metrics-filter class=anchor aria-hidden=true>#</a></h3><p>要启用网关指标，请添加<code>spring-boot-starter-actuator</code>作为项目依赖。然后，默认情况下，只要属性<code>spring.cloud.gateway.metrics.enabled</code>没有设置为<code>false</code>，网关指标过滤器就会运行。这个过滤器添加了一个名为<code>gateway.requests</code>的定时器指标，标签如下。</p><ul><li><code>routeId</code> : 路径ID。</li><li><code>routeUri</code> : API被路由到的URI。</li><li><code>outcome</code> : 结果，由<a href=https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/http/HttpStatus.Series.html>HttpStatus.Series</a>分类。</li><li><code>status</code> : 返回给客户端的请求的HTTP状态。</li><li><code>httpStatusCode</code> : 返回给客户端的请求的HTTP状态。</li><li><code>httpMethod</code> : 请求使用的HTTP方法。</li></ul><p>这些指标可以从<code>/actuator/metrics/gateway.requests</code>中获取，并可以很容易地与Prometheus集成，创建一个<a href=https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/images/gateway-grafana-dashboard.jpeg>Grafana</a> <a href=https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/gateway-grafana-dashboard.json>仪表盘</a>。</p><blockquote><p>要启用Prometheus端点，请添加<code>micrometer-registry-prometheus</code>作为项目依赖。</p></blockquote><h3 id=79-marking-an-exchange-as-routed>7.9. Marking An Exchange As Routed<a href=#79-marking-an-exchange-as-routed class=anchor aria-hidden=true>#</a></h3><p>在网关路由了一个<code>ServerWeb Exchange</code>后，它通过在exchange attributes中添加<code>gatewayAlreadyRouted</code>来标记该交换为 &ldquo;routed&rdquo;。一旦一个请求被标记为已路由，其他的路由过滤器将不再对该请求进行路由，基本上是跳过该过滤器。有一些方便的方法，你可以用来标记一个交换为路由，或者检查一个交换是否已经被路由。</p><ul><li><code>ServerWebExchangeUtils.isAlreadyRouted</code>接收一个<code>ServerWebExchange</code>对象并检查它是否已经被 &ldquo;routed&rdquo;。</li><li><code>ServerWebExchangeUtils.setAlreadyRouted</code>接收一个<code>ServerWebExchange</code>对象并将其标记为 &ldquo;routed&rdquo;。</li></ul><h2 id=8-httpheadersfilters>8. HttpHeadersFilters<a href=#8-httpheadersfilters class=anchor aria-hidden=true>#</a></h2><p>HttpHeadersFilters在向下游发送请求之前被应用于请求，例如在NettyRoutingFilter。</p><h3 id=81-forwarded-headers-filter>8.1. Forwarded Headers Filter<a href=#81-forwarded-headers-filter class=anchor aria-hidden=true>#</a></h3><p>Forwarded Headers Filter创建一个Forwarded header来发送给下游的服务。它将当前请求的主机头、方案和端口添加到任何现有的转发头中。</p><h3 id=82-removehopbyhop-headers-filter>8.2. RemoveHopByHop Headers Filter<a href=#82-removehopbyhop-headers-filter class=anchor aria-hidden=true>#</a></h3><p><code>RemoveHopByHop Headers Filter</code> 从转发的请求中删除头信息。被移除的默认头信息列表来自<a href=https://tools.ietf.org/html/draft-ietf-httpbis-p1-messaging-14#section-7.1.3>IETF</a>。</p><p>默认删除的header是:</p><ul><li>Connection</li><li>Keep-Alive</li><li>Proxy-Authenticate</li><li>Proxy-Authorization</li><li>TE</li><li>Trailer</li><li>Transfer-Encoding</li><li>Upgrade</li></ul><p>要改变这一点，请将<code>spring.cloud.gateway.filter.remove-hop-by-hop.headers</code>属性设置为要删除的头名称列表。</p><h3 id=83-xforwarded-headers-filter>8.3. XForwarded Headers Filter<a href=#83-xforwarded-headers-filter class=anchor aria-hidden=true>#</a></h3><p>XForwarded Headers Filter创建各种<code>X-Forwarded-*</code>头，以发送到下游服务。它使用当前请求的Host头、方案、端口和路径来创建各种头。</p><p>创建各个头信息可以由以下布尔属性控制（默认为true）。</p><ul><li><code>spring.cloud.gateway.x-forwarded.for-enabled</code></li><li><code>spring.cloud.gateway.x-forwarded.host-enabled</code></li><li><code>spring.cloud.gateway.x-forwarded.port-enabled</code></li><li><code>spring.cloud.gateway.x-forwarded.proto-enabled</code></li><li><code>spring.cloud.gateway.x-forwarded.prefix-enabled</code></li></ul><p>附加多个header可以由以下布尔属性控制（默认为真）。</p><ul><li><code>spring.cloud.gateway.x-forwarded.for-append</code></li><li><code>spring.cloud.gateway.x-forwarded.host-append</code></li><li><code>spring.cloud.gateway.x-forwarded.port-append</code></li><li><code>spring.cloud.gateway.x-forwarded.proto-append</code></li><li><code>spring.cloud.gateway.x-forwarded.prefix-append</code></li></ul><h2 id=9-tls-and-ssl>9. TLS and SSL<a href=#9-tls-and-ssl class=anchor aria-hidden=true>#</a></h2><p>网关可以通过遵循通常的Spring服务器配置来监听HTTPS请求。下面的例子显示了如何做到这一点。</p><p>Example 58. application.yml</p><pre><code class=language-yaml>server:
  ssl:
    enabled: true
    key-alias: scg
    key-store-password: scg1234
    key-store: classpath:scg-keystore.p12
    key-store-type: PKCS12
</code></pre><p>你可以将网关路由到HTTP和HTTPS后端。如果你要路由到HTTPS后端，你可以通过以下配置将网关配置为信任所有下游的证书。</p><p>Example 59. application.yml</p><pre><code class=language-yaml>spring:
  cloud:
    gateway:
      httpclient:
        ssl:
          useInsecureTrustManager: true
</code></pre><p>使用不安全的信任管理器不适合于生产。对于生产部署，你可以用一组已知的证书来配置网关，它可以通过以下配置来信任。</p><p>Example 60. application.yml</p><pre><code class=language-yaml>spring:
  cloud:
    gateway:
      httpclient:
        ssl:
          trustedX509Certificates:
          - cert1.pem
          - cert2.pem
</code></pre><p>如果Spring Cloud Gateway没有配置受信任的证书，就会使用默认的信任存储（你可以通过设置<code>javax.net.ssl.trustStore</code>系统属性来覆盖它）。</p><h3 id=91-tls-handshake>9.1. TLS Handshake<a href=#91-tls-handshake class=anchor aria-hidden=true>#</a></h3><p>网关维护着一个客户端池，它用来路由到后端。当通过HTTPS进行通信时，客户端发起了一个TLS握手。一些超时与这个握手相关。你可以对这些超时进行配置（默认值显示），如下。</p><p>Example 61. application.yml</p><pre><code class=language-yaml>spring:
  cloud:
    gateway:
      httpclient:
        ssl:
          handshake-timeout-millis: 10000
          close-notify-flush-timeout-millis: 3000
          close-notify-read-timeout-millis: 0
</code></pre><h2 id=10-configuration>10. Configuration<a href=#10-configuration class=anchor aria-hidden=true>#</a></h2><p>Spring Cloud Gateway的配置是由<code>RouteDefinitionLocator</code>实例的集合驱动的。下面的列表显示了<code>RouteDefinitionLocator</code>接口的定义。</p><p>Example 62. RouteDefinitionLocator.java</p><pre><code class=language-java>public interface RouteDefinitionLocator {
    Flux&lt;RouteDefinition&gt; getRouteDefinitions();
}
</code></pre><p>默认情况下，<code>PropertiesRouteDefinitionLocator</code>通过使用Spring Boot的<code>@ConfigurationProperties</code>机制加载属性。</p><p>前面的配置例子都使用了一种快捷的符号，即使用位置参数而不是命名参数。下面的两个例子是等价的。</p><p>Example 63. application.yml</p><pre><code class=language-yaml>spring:
  cloud:
    gateway:
      routes:
      - id: setstatus_route
        uri: https://example.org
        filters:
        - name: SetStatus
          args:
            status: 401
      - id: setstatusshortcut_route
        uri: https://example.org
        filters:
        - SetStatus=401
</code></pre><p>对于网关的某些用途来说，属性已经足够了，但一些生产用例会从外部来源（如数据库）加载配置中受益。未来的里程碑版本将有基于Spring数据存储库的<code>RouteDefinitionLocator</code>实现，如<code>Redis</code>、<code>MongoDB</code>和<code>Cassandra</code>。</p><h2 id=11-route-metadata-configuration>11. Route Metadata Configuration<a href=#11-route-metadata-configuration class=anchor aria-hidden=true>#</a></h2><p>你可以通过使用元数据为每个途径配置额外的参数，如下所示。</p><p>Example 64. application.yml</p><pre><code class=language-yaml>spring:
  cloud:
    gateway:
      routes:
      - id: route_with_metadata
        uri: https://example.org
        metadata:
          optionName: &quot;OptionValue&quot;
          compositeObject:
            name: &quot;value&quot;
          iAmNumber: 1
</code></pre><p>你可以从一个exchange所获取所有的元数据属性，如下所示。</p><pre><code class=language-java>Route route = exchange.getAttribute(GATEWAY_ROUTE_ATTR);
// get all metadata properties
route.getMetadata();
// get a single metadata property
route.getMetadata(someKey);
</code></pre><h2 id=12-http-timeouts-configuration>12. Http timeouts configuration<a href=#12-http-timeouts-configuration class=anchor aria-hidden=true>#</a></h2><p>可以为所有路由配置Http超时（响应和连接），也可以为每个特定的路由重写。</p><h3 id=121-全局超时>12.1. 全局超时<a href=#121-全局超时 class=anchor aria-hidden=true>#</a></h3><p>要配置全局http超时。
<code>connect-timeout</code> 必须以毫秒为单位指定。
<code>response-timeout</code> 必须以<code>java.time.Duration</code>的形式指定。</p><p>全局超时</p><pre><code class=language-yaml>spring:
  cloud:
    gateway:
      httpclient:
        connect-timeout: 1000
        response-timeout: 5s
</code></pre><h3 id=122-每个路由的超时>12.2. 每个路由的超时<a href=#122-每个路由的超时 class=anchor aria-hidden=true>#</a></h3><p>要配置每个路由的超时。
<code>connect-timeout</code>必须以毫秒为单位指定。
<code>response-timeout</code> 必须以毫秒为单位指定。</p><p>通过yaml配置每个路由的超时</p><pre><code class=language-YAML>      - id: per_route_timeouts
        uri: https://example.org
        predicates:
          - name: Path
            args:
              pattern: /delay/{timeout}
        metadata:
          response-timeout: 200
          connect-timeout: 200
</code></pre><p>使用Java DSL配置每个路由的超时</p><pre><code class=language-java>import static org.springframework.cloud.gateway.support.RouteMetadataUtils.CONNECT_TIMEOUT_ATTR;
import static org.springframework.cloud.gateway.support.RouteMetadataUtils.RESPONSE_TIMEOUT_ATTR;

      @Bean
      public RouteLocator customRouteLocator(RouteLocatorBuilder routeBuilder){
         return routeBuilder.routes()
               .route(&quot;test1&quot;, r -&gt; {
                  return r.host(&quot;*.somehost.org&quot;).and().path(&quot;/somepath&quot;)
                        .filters(f -&gt; f.addRequestHeader(&quot;header1&quot;, &quot;header-value-1&quot;))
                        .uri(&quot;http://someuri&quot;)
                        .metadata(RESPONSE_TIMEOUT_ATTR, 200)
                        .metadata(CONNECT_TIMEOUT_ATTR, 200);
               })
               .build();
      }
</code></pre><h3 id=123-fluent-java-routes-api>12.3. Fluent Java Routes API<a href=#123-fluent-java-routes-api class=anchor aria-hidden=true>#</a></h3><p>为了允许在Java中进行简单的配置，RouteLocatorBuilder Bean包括一个fluent的API。下面的列表显示了它是如何工作的。</p><p>Example 65. GatewaySampleApplication.java</p><pre><code class=language-java>// static imports from GatewayFilters and RoutePredicates
@Bean
public RouteLocator customRouteLocator(RouteLocatorBuilder builder, ThrottleGatewayFilterFactory throttle) {
    return builder.routes()
            .route(r -&gt; r.host(&quot;**.abc.org&quot;).and().path(&quot;/image/png&quot;)
                .filters(f -&gt;
                        f.addResponseHeader(&quot;X-TestHeader&quot;, &quot;foobar&quot;))
                .uri(&quot;http://httpbin.org:80&quot;)
            )
            .route(r -&gt; r.path(&quot;/image/webp&quot;)
                .filters(f -&gt;
                        f.addResponseHeader(&quot;X-AnotherHeader&quot;, &quot;baz&quot;))
                .uri(&quot;http://httpbin.org:80&quot;)
                .metadata(&quot;key&quot;, &quot;value&quot;)
            )
            .route(r -&gt; r.order(-1)
                .host(&quot;**.throttle.org&quot;).and().path(&quot;/get&quot;)
                .filters(f -&gt; f.filter(throttle.apply(1,
                        1,
                        10,
                        TimeUnit.SECONDS)))
                .uri(&quot;http://httpbin.org:80&quot;)
                .metadata(&quot;key&quot;, &quot;value&quot;)
            )
            .build();
}
</code></pre><p>这种风格也允许更多的自定义谓词断言。由<code>RouteDefinitionLocator</code> Bean定义的谓词使用逻辑上的和来组合。通过使用流畅的Java API，你可以在<code>Predicate</code>类上使用<code>and()</code>、<code>or()</code>和<code>negate()</code>操作符。</p><h3 id=124-the-discoveryclient-route-definition-locator>12.4. The DiscoveryClient Route Definition Locator<a href=#124-the-discoveryclient-route-definition-locator class=anchor aria-hidden=true>#</a></h3><p>你可以将网关配置为基于在<code>DiscoveryClient</code>兼容的服务注册中心注册的服务来创建路由。</p><p>要启用这一点，请设置<code>spring.cloud.gateway.discovery.locator.enabled=true</code>，并确保<code>DiscoveryClien</code>t`实现（如Netflix Eureka、Consul或Zookeeper）位于classpath上并已启用。</p><h4 id=1241-为discoveryclient路由配置谓词和过滤器>12.4.1. 为DiscoveryClient路由配置谓词和过滤器<a href=#1241-为discoveryclient路由配置谓词和过滤器 class=anchor aria-hidden=true>#</a></h4><p>默认情况下，网关为用<code>DiscoveryClient</code>创建的路由定义了一个谓词和过滤器。</p><p>默认谓词是用<code>/serviceId/**</code>模式定义的路径谓词，其中<code>serviceId</code>是来自<code>DiscoveryClient</code>的服务的ID。</p><p>默认过滤器是一个重写路径过滤器，采用重写词<code>/serviceId/?(?&lt;remaining>.*)</code>和替换词<code>/${remaining}</code>。在请求被发送到下游之前，这将从路径中剥离服务ID。</p><p>如果你想自定义<code>DiscoveryClient</code>路由使用的谓词或过滤器，请设置<code>spring.cloud.gateway.discovery.locator.predicates[x]</code> 和 <code>spring.cloud.gateway.discovery.locator.filters[y]</code>。这样做时，如果你想保留该功能，你需要确保包括前面显示的默认谓词和过滤器。下面的例子显示了这是什么样子。</p><p>Example 66. application.properties</p><pre><code class=language-properties>spring.cloud.gateway.discovery.locator.predicates[0].name: Path
spring.cloud.gateway.discovery.locator.predicates[0].args[pattern]: &quot;'/'+serviceId+'/**'&quot;
spring.cloud.gateway.discovery.locator.predicates[1].name: Host
spring.cloud.gateway.discovery.locator.predicates[1].args[pattern]: &quot;'**.foo.com'&quot;
spring.cloud.gateway.discovery.locator.filters[0].name: CircuitBreaker
spring.cloud.gateway.discovery.locator.filters[0].args[name]: serviceId
spring.cloud.gateway.discovery.locator.filters[1].name: RewritePath
spring.cloud.gateway.discovery.locator.filters[1].args[regexp]: &quot;'/' + serviceId + '/?(?&lt;remaining&gt;.*)'&quot;
spring.cloud.gateway.discovery.locator.filters[1].args[replacement]: &quot;'/${remaining}'&quot;
</code></pre><h2 id=13-reactor-netty-访问日志>13. Reactor Netty 访问日志<a href=#13-reactor-netty-访问日志 class=anchor aria-hidden=true>#</a></h2><p>要启用 Reactor Netty 访问日志，设置 <code>-Dreactor.netty.http.server.accessLogEnabled=true</code>。</p><blockquote><p>它必须是一个Java系统属性，而不是一个Spring Boot属性。</p></blockquote><p>你可以配置日志系统，使其有一个单独的访问日志文件。下面的例子创建了一个Logback配置。</p><p>Example 67. logback.xml</p><pre><code class=language-xml>    &lt;appender name=&quot;accessLog&quot; class=&quot;ch.qos.logback.core.FileAppender&quot;&gt;
        &lt;file&gt;access_log.log&lt;/file&gt;
        &lt;encoder&gt;
            &lt;pattern&gt;%msg%n&lt;/pattern&gt;
        &lt;/encoder&gt;
    &lt;/appender&gt;
    &lt;appender name=&quot;async&quot; class=&quot;ch.qos.logback.classic.AsyncAppender&quot;&gt;
        &lt;appender-ref ref=&quot;accessLog&quot; /&gt;
    &lt;/appender&gt;

    &lt;logger name=&quot;reactor.netty.http.server.AccessLog&quot; level=&quot;INFO&quot; additivity=&quot;false&quot;&gt;
        &lt;appender-ref ref=&quot;async&quot;/&gt;
    &lt;/logger&gt;
</code></pre><h2 id=14-cors-跨域配置>14. CORS 跨域配置<a href=#14-cors-跨域配置 class=anchor aria-hidden=true>#</a></h2><p>你可以配置网关来控制CORS行为。全局CORS配置是URL模式与<a href=https://docs.spring.io/spring/docs/5.0.x/javadoc-api/org/springframework/web/cors/CorsConfiguration.html>Spring Framework <code>CorsConfiguration</code></a>的映射。下面的例子配置了CORS。</p><p>Example 68. application.yml</p><pre><code class=language-yaml>spring:
  cloud:
    gateway:
      globalcors:
        cors-configurations:
          '[/**]':
            allowedOrigins: &quot;https://docs.spring.io&quot;
            allowedMethods:
            - GET
</code></pre><p>在前面的例子中，对于所有 GET 请求路径，允许来自 <code>docs.spring.io</code> 的请求的 CORS 请求。</p><p>要为未被某些网关路由谓词处理的请求提供相同的 CORS 配置，请将 s<code>pring.cloud.gateway.globalcors.add-to-simple-url-handler-mapping</code> 属性设置为 <code>true</code>。当你试图支持 CORS 预检请求，而你的路由谓词因为 HTTP 方法是选项而不能评估为 true 时，这很有用。</p><h2 id=15-actuator-api>15. Actuator API<a href=#15-actuator-api class=anchor aria-hidden=true>#</a></h2><p><code>/gateway</code>执行器端点可以让你监控并与Spring Cloud Gateway应用互动。要进行远程访问，端点必须在应用程序属性中<a href=https://docs.spring.io/spring-boot/docs/current/reference/html/production-ready-endpoints.html#production-ready-endpoints-enabling-endpoints>启用</a>和<a href=https://docs.spring.io/spring-boot/docs/current/reference/html/production-ready-endpoints.html#production-ready-endpoints-exposing-endpoints>通过HTTP或JMX暴露</a>。下面的列表显示了如何做到这一点。</p><p>Example 69. application.properties</p><pre><code class=language-properties>management.endpoint.gateway.enabled=true # default value
management.endpoints.web.exposure.include=gateway
</code></pre><h3 id=151-verbose-actuator-format>15.1. Verbose Actuator Format<a href=#151-verbose-actuator-format class=anchor aria-hidden=true>#</a></h3><p>在Spring Cloud Gateway中增加了一种新的、更粗略的格式。它为每个路由添加了更多细节，让你查看与每个路由相关的谓词和过滤器，以及任何可用的配置。下面的例子配置了<code>/actuator/gateway/routes</code>。</p><pre><code class=language-json>[
  {
    &quot;predicate&quot;: &quot;(Hosts: [**.addrequestheader.org] &amp;&amp; Paths: [/headers], match trailing slash: true)&quot;,
    &quot;route_id&quot;: &quot;add_request_header_test&quot;,
    &quot;filters&quot;: [
      &quot;[[AddResponseHeader X-Response-Default-Foo = 'Default-Bar'], order = 1]&quot;,
      &quot;[[AddRequestHeader X-Request-Foo = 'Bar'], order = 1]&quot;,
      &quot;[[PrefixPath prefix = '/httpbin'], order = 2]&quot;
    ],
    &quot;uri&quot;: &quot;lb://testservice&quot;,
    &quot;order&quot;: 0
  }
]
</code></pre><p>这个功能默认是启用的。要禁用它，请设置以下属性。</p><p>Example 70. application.properties</p><pre><code class=language-properties>spring.cloud.gateway.actuator.verbose.enabled=false
</code></pre><p>在未来的版本中，这将默认为<code>true</code></p><h3 id=152-retrieving-route-filters>15.2. Retrieving Route Filters<a href=#152-retrieving-route-filters class=anchor aria-hidden=true>#</a></h3><p>本节详细介绍了如何检索路由过滤器，包括。</p><ul><li><a href=https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#gateway-global-filters>Global Filters</a></li><li><a href=https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#gateway-route-filters>[gateway-route-filters]</a></li></ul><h4 id=1521-global-filters>15.2.1. Global Filters<a href=#1521-global-filters class=anchor aria-hidden=true>#</a></h4><p>要检索应用于所有路由的<a href=https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#global-filters>全局过滤器</a>，向<code>/actuator/gateway/globalfilters</code>发出<code>GET</code>请求。得到的响应类似于以下内容。</p><pre><code class=language-json>{
  &quot;org.springframework.cloud.gateway.filter.ReactiveLoadBalancerClientFilter@77856cc5&quot;: 10100,
  &quot;org.springframework.cloud.gateway.filter.RouteToRequestUrlFilter@4f6fd101&quot;: 10000,
  &quot;org.springframework.cloud.gateway.filter.NettyWriteResponseFilter@32d22650&quot;: -1,
  &quot;org.springframework.cloud.gateway.filter.ForwardRoutingFilter@106459d9&quot;: 2147483647,
  &quot;org.springframework.cloud.gateway.filter.NettyRoutingFilter@1fbd5e0&quot;: 2147483647,
  &quot;org.springframework.cloud.gateway.filter.ForwardPathFilter@33a71d23&quot;: 0,
  &quot;org.springframework.cloud.gateway.filter.AdaptCachedBodyGlobalFilter@135064ea&quot;: 2147483637,
  &quot;org.springframework.cloud.gateway.filter.WebsocketRoutingFilter@23c05889&quot;: 2147483646
}
</code></pre><p>响应包含全局过滤器的细节，这些过滤器已经到位。对于每个全局过滤器，有一个过滤器对象的字符串表示（例如，<code>org.springframework.cloud.gateway.filter.ReactiveLoadBalancerClientFilter@77856cc5</code>）和过滤器链中相应的<a href=https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#gateway-combined-global-filter-and-gatewayfilter-ordering>order</a>。 }。</p><h4 id=1522-route-filters>15.2.2. Route Filters<a href=#1522-route-filters class=anchor aria-hidden=true>#</a></h4><p>要检索应用于路由的<a href=https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#gatewayfilter-factories><code>GatewayFilter</code>工厂</a>，向<code>/actuator/gateway/routefilters</code>发出<code>GET</code>请求。得到的响应类似于以下内容。</p><pre><code class=language-json>{
  &quot;[AddRequestHeaderGatewayFilterFactory@570ed9c configClass = AbstractNameValueGatewayFilterFactory.NameValueConfig]&quot;: null,
  &quot;[SecureHeadersGatewayFilterFactory@fceab5d configClass = Object]&quot;: null,
  &quot;[SaveSessionGatewayFilterFactory@4449b273 configClass = Object]&quot;: null
}
</code></pre><p>响应包含应用于任何特定路由的<code>GatewayFilter</code>工厂的细节。对于每个工厂，有一个相应对象的字符串表示（例如，<code>[SecureHeadersGatewayFilterFactory@fceab5d configClass = Object]</code>）。请注意，<code>null</code> 是由于端点控制器的不完整实现，因为它试图设置过滤器链中的对象的顺序，这不适用于<code>GatewayFilter</code>工厂对象。</p><h3 id=153-刷新路由缓存>15.3. 刷新路由缓存<a href=#153-刷新路由缓存 class=anchor aria-hidden=true>#</a></h3><p>要清除路由缓存，请向<code>/actuator/gateway/refresh</code>发出一个<code>POST</code>请求。该请求返回一个200，没有响应体。</p><h3 id=154-检索网关中定义的路由>15.4. 检索网关中定义的路由<a href=#154-检索网关中定义的路由 class=anchor aria-hidden=true>#</a></h3><p>要检索网关中定义的路由，请向<code>/actuator/gateway/routes</code>发出<code>GET</code>请求。得到的响应类似于以下内容。</p><pre><code class=language-json>[{
  &quot;route_id&quot;: &quot;first_route&quot;,
  &quot;route_object&quot;: {
    &quot;predicate&quot;: &quot;org.springframework.cloud.gateway.handler.predicate.PathRoutePredicateFactory$$Lambda$432/1736826640@1e9d7e7d&quot;,
    &quot;filters&quot;: [
      &quot;OrderedGatewayFilter{delegate=org.springframework.cloud.gateway.filter.factory.PreserveHostHeaderGatewayFilterFactory$$Lambda$436/674480275@6631ef72, order=0}&quot;
    ]
  },
  &quot;order&quot;: 0
},
{
  &quot;route_id&quot;: &quot;second_route&quot;,
  &quot;route_object&quot;: {
    &quot;predicate&quot;: &quot;org.springframework.cloud.gateway.handler.predicate.PathRoutePredicateFactory$$Lambda$432/1736826640@cd8d298&quot;,
    &quot;filters&quot;: []
  },
  &quot;order&quot;: 0
}]
</code></pre><p>响应包含网关中定义的所有路由的详细信息。下表描述了响应中每个元素的结构（每个都是一个路由）。</p><table><thead><tr><th>Path</th><th>Type</th><th>Description</th></tr></thead><tbody><tr><td><code>route_id</code></td><td>String</td><td>路由ID</td></tr><tr><td><code>route_object.predicate</code></td><td>Object</td><td>路由 predicate</td></tr><tr><td><code>route_object.filters</code></td><td>Array</td><td>应用于路由的<a href=https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#gatewayfilter-factories><code>GatewayFilter</code>工厂</a></td></tr><tr><td><code>order</code></td><td>Number</td><td>路由 order</td></tr></tbody></table><h3 id=155-检索指定路由的信息>15.5. 检索指定路由的信息<a href=#155-检索指定路由的信息 class=anchor aria-hidden=true>#</a></h3><p>要检索一条路由的信息，请向<code>/actuator/gateway/routes/{id}</code>发出一个GET请求。(例如，<code>/actuator/gateway/routes/first_route)</code>。得到的响应类似于下面的内容。</p><pre><code class=language-json>{
  &quot;id&quot;: &quot;first_route&quot;,
  &quot;predicates&quot;: [{
    &quot;name&quot;: &quot;Path&quot;,
    &quot;args&quot;: {&quot;_genkey_0&quot;:&quot;/first&quot;}
  }],
  &quot;filters&quot;: [],
  &quot;uri&quot;: &quot;https://www.uri-destination.org&quot;,
  &quot;order&quot;: 0
}]
</code></pre><p>下表描述了响应的结构。</p><table><thead><tr><th>Path</th><th>Type</th><th>Description</th></tr></thead><tbody><tr><td><code>id</code></td><td>String</td><td>路由ID</td></tr><tr><td><code>predicates</code></td><td>Array</td><td>路由谓词的集合。每一项都定义了一个给定谓词的名称和参数。</td></tr><tr><td><code>filters</code></td><td>Array</td><td>应用于路由的过滤器集合。</td></tr><tr><td><code>uri</code></td><td>String</td><td>路由的目的地URI。</td></tr><tr><td><code>order</code></td><td>Number</td><td>路由的顺序</td></tr></tbody></table><h3 id=156-创建和删除一个指定的路由>15.6. 创建和删除一个指定的路由<a href=#156-创建和删除一个指定的路由 class=anchor aria-hidden=true>#</a></h3><p>要创建一个路由，请向<code>/gateway/routes/{id_route_to_create}</code>发出<code>POST</code>请求，并以JSON为主体指定路由的字段（见<a href=https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#gateway-retrieving-information-about-a-particular-route>检索特定路由的信息</a>）。</p><p>要删除一个路由，请向<code>/gateway/routes/{id_route_to_delete}</code>发出<code>DELETE</code>请求。</p><h3 id=157-总结所有端点的清单>15.7. 总结：所有端点的清单<a href=#157-总结所有端点的清单 class=anchor aria-hidden=true>#</a></h3><p>下面的表格总结了Spring Cloud Gateway的执行器端点（注意，每个端点都有<code>/actuator/gateway</code>作为基本路径）。</p><table><thead><tr><th>ID</th><th>HTTP Method</th><th>Description</th></tr></thead><tbody><tr><td><code>globalfilters</code></td><td>GET</td><td>显示应用于路由的全局过滤器的列表。</td></tr><tr><td><code>routefilters</code></td><td>GET</td><td>显示应用于特定路由的 <code>GatewayFilter</code>工厂的列表。</td></tr><tr><td><code>refresh</code></td><td>POST</td><td>清楚路由缓存</td></tr><tr><td><code>routes</code></td><td>GET</td><td>D显示网关中定义的路由列表</td></tr><tr><td><code>routes/{id}</code></td><td>GET</td><td>显示指定路由的详细信息</td></tr><tr><td><code>routes/{id}</code></td><td>POST</td><td>添加一个新的路由到网关</td></tr><tr><td><code>routes/{id}</code></td><td>DELETE</td><td>从网关删除一个路由</td></tr></tbody></table><h2 id=16-故障排除>16. 故障排除<a href=#16-故障排除 class=anchor aria-hidden=true>#</a></h2><p>本节涵盖了你在使用Spring Cloud Gateway时可能出现的常见问题。</p><h3 id=161-日志级别>16.1. 日志级别<a href=#161-日志级别 class=anchor aria-hidden=true>#</a></h3><p>在<code>DEBUG</code>和<code>TRACE</code>级别，以下记录器可能包含有价值的故障排除信息。</p><ul><li><code>org.springframework.cloud.gateway</code></li><li><code>org.springframework.http.server.reactive</code></li><li><code>org.springframework.web.reactive</code></li><li><code>org.springframework.boot.autoconfigure.web</code></li><li><code>reactor.netty</code></li><li><code>redisratelimiter</code></li></ul><h3 id=162-wiretap>16.2. Wiretap<a href=#162-wiretap class=anchor aria-hidden=true>#</a></h3><p>Reactor Netty的HttpClient和HttpServer可以启用wiretap。当与 reactor.netty 日志级别设置为 DEBUG 或 TRACE 相结合时，它能够记录信息，例如通过线路发送和接收的头信息和正文。要启用 wiretap，请分别为 HttpServer 和 HttpClient 设置 <code>spring.cloud.gateway.httpserver.wiretap=true</code> 或 <code>spring.cloud.gateway.httpclient.wiretap=true</code>。</p><h2 id=17-开发者指南>17. 开发者指南<a href=#17-开发者指南 class=anchor aria-hidden=true>#</a></h2><p>这些是编写网关的一些自定义组件的基本指南。</p><h3 id=171-编写自定义路由谓语工厂>17.1. 编写自定义路由谓语工厂<a href=#171-编写自定义路由谓语工厂 class=anchor aria-hidden=true>#</a></h3><p>为了编写一个Route Predicate，你将需要实现<code>RoutePredicateFactory</code>。有一个抽象的类叫做<code>AbstractRoutePredicateFactory</code>，你可以扩展它。</p><p>MyRoutePredicateFactory.java</p><pre><code class=language-java>public class MyRoutePredicateFactory extends AbstractRoutePredicateFactory&lt;HeaderRoutePredicateFactory.Config&gt; {

    public MyRoutePredicateFactory() {
        super(Config.class);
    }

    @Override
    public Predicate&lt;ServerWebExchange&gt; apply(Config config) {
        // grab configuration from Config object
        return exchange -&gt; {
            //grab the request
            ServerHttpRequest request = exchange.getRequest();
            //take information from the request to see if it
            //matches configuration.
            return matches(config, request);
        };
    }

    public static class Config {
        //Put the configuration properties for your filter here
    }

}
</code></pre><h3 id=172-编写自定义gatewayfilter工厂>17.2. 编写自定义GatewayFilter工厂<a href=#172-编写自定义gatewayfilter工厂 class=anchor aria-hidden=true>#</a></h3><p>要写一个<code>GatewayFilter</code>，你必须实现<code>GatewayFilterFactory</code>。你可以扩展一个名为<code>AbstractGatewayFilterFactory</code>的抽象类。下面的例子展示了如何做到这一点。</p><p>Example 71. PreGatewayFilterFactory.java</p><pre><code class=language-java>public class PreGatewayFilterFactory extends AbstractGatewayFilterFactory&lt;PreGatewayFilterFactory.Config&gt; {

    public PreGatewayFilterFactory() {
        super(Config.class);
    }

    @Override
    public GatewayFilter apply(Config config) {
        // grab configuration from Config object
        return (exchange, chain) -&gt; {
            //If you want to build a &quot;pre&quot; filter you need to manipulate the
            //request before calling chain.filter
            ServerHttpRequest.Builder builder = exchange.getRequest().mutate();
            //use builder to manipulate the request
            return chain.filter(exchange.mutate().request(builder.build()).build());
        };
    }

    public static class Config {
        //Put the configuration properties for your filter here
    }

}
</code></pre><p>PostGatewayFilterFactory.java</p><pre><code class=language-java>public class PostGatewayFilterFactory extends AbstractGatewayFilterFactory&lt;PostGatewayFilterFactory.Config&gt; {

    public PostGatewayFilterFactory() {
        super(Config.class);
    }

    @Override
    public GatewayFilter apply(Config config) {
        // grab configuration from Config object
        return (exchange, chain) -&gt; {
            return chain.filter(exchange).then(Mono.fromRunnable(() -&gt; {
                ServerHttpResponse response = exchange.getResponse();
                //Manipulate the response in some way
            }));
        };
    }

    public static class Config {
        //Put the configuration properties for your filter here
    }

}
</code></pre><h4 id=1721-在配置中命名自定义过滤器和引用>17.2.1. 在配置中命名自定义过滤器和引用<a href=#1721-在配置中命名自定义过滤器和引用 class=anchor aria-hidden=true>#</a></h4><p>自定义过滤器的类名应该以<code>GatewayFilterFactory</code>结尾。</p><p>例如，要在配置文件中引用一个名为<code>Something</code>的过滤器，该过滤器必须在一个名为<code>SomethingGatewayFilterFactory</code>的类中。</p><blockquote><p>可以创建一个没有<code>GatewayFilterFactory</code>后缀的网关过滤器，如<code>AnotherThing</code>类。这个过滤器可以在配置文件中被引用为<code>AnotherThing</code>。这不是一个被支持的命名惯例，这种语法可能在未来的版本中被删除。请更新过滤器的名称，使其符合要求。</p></blockquote><h3 id=173-writing-custom-global-filters>17.3. Writing Custom Global Filters<a href=#173-writing-custom-global-filters class=anchor aria-hidden=true>#</a></h3><p>要编写一个自定义的全局过滤器，你必须实现<code>GlobalFilter</code>接口。这将过滤器应用于所有的请求。</p><p>下面的例子分别展示了如何设置全局前置和后置过滤器。</p><pre><code class=language-java>@Bean
public GlobalFilter customGlobalFilter() {
    return (exchange, chain) -&gt; exchange.getPrincipal()
        .map(Principal::getName)
        .defaultIfEmpty(&quot;Default User&quot;)
        .map(userName -&gt; {
          //adds header to proxied request
          exchange.getRequest().mutate().header(&quot;CUSTOM-REQUEST-HEADER&quot;, userName).build();
          return exchange;
        })
        .flatMap(chain::filter);
}

@Bean
public GlobalFilter customGlobalPostFilter() {
    return (exchange, chain) -&gt; chain.filter(exchange)
        .then(Mono.just(exchange))
        .map(serverWebExchange -&gt; {
          //adds header to response
          serverWebExchange.getResponse().getHeaders().set(&quot;CUSTOM-RESPONSE-HEADER&quot;,
              HttpStatus.OK.equals(serverWebExchange.getResponse().getStatusCode()) ? &quot;It worked&quot;: &quot;It did not work&quot;);
          return serverWebExchange;
        })
        .then();
}
</code></pre><h2 id=18-通过使用spring-mvc或webflux构建一个简单的网关>18. 通过使用Spring MVC或Webflux构建一个简单的网关<a href=#18-通过使用spring-mvc或webflux构建一个简单的网关 class=anchor aria-hidden=true>#</a></h2><blockquote><p>下面描述的是另一种风格的网关。之前的文档都不适用于下面的内容。</p></blockquote><p>Spring Cloud Gateway提供了一个名为<code>ProxyExchange</code>的实用对象。你可以在常规的Spring网络处理程序中作为一个方法参数使用它。它通过反映HTTP动词的方法支持基本的下游HTTP交换。在MVC中，它还支持通过<code>forward()</code>方法转发到本地处理程序。要使用<code>ProxyExchange</code>，在你的classpath中包含正确的模块（<code>spring-cloud-gateway-mvc或spring-cloud-gateway-webflux</code>）。</p><p>下面的MVC例子将一个到/test的请求代理到一个远程服务器。</p><pre><code class=language-java>@RestController
@SpringBootApplication
public class GatewaySampleApplication {

    @Value(&quot;${remote.home}&quot;)
    private URI home;

    @GetMapping(&quot;/test&quot;)
    public ResponseEntity&lt;?&gt; proxy(ProxyExchange&lt;byte[]&gt; proxy) throws Exception {
        return proxy.uri(home.toString() + &quot;/image/png&quot;).get();
    }

}
</code></pre><p>下面的例子用Webflux做同样的事情。</p><pre><code class=language-java>@RestController
@SpringBootApplication
public class GatewaySampleApplication {

    @Value(&quot;${remote.home}&quot;)
    private URI home;

    @GetMapping(&quot;/test&quot;)
    public Mono&lt;ResponseEntity&lt;?&gt;&gt; proxy(ProxyExchange&lt;byte[]&gt; proxy) throws Exception {
        return proxy.uri(home.toString() + &quot;/image/png&quot;).get();
    }

}
</code></pre><p><code>ProxyExchange</code>上的便利方法使处理方法能够发现并增强传入请求的URI路径。例如，你可能想提取路径的尾部元素，将它们传递到下游。</p><pre><code class=language-java>@GetMapping(&quot;/proxy/path/**&quot;)
public ResponseEntity&lt;?&gt; proxyPath(ProxyExchange&lt;byte[]&gt; proxy) throws Exception {
  String path = proxy.path(&quot;/proxy/path/&quot;);
  return proxy.uri(home.toString() + &quot;/foos/&quot; + path).get();
}
</code></pre><p>Spring MVC和Webflux的所有功能都可用于网关处理方法。因此，你可以注入请求头和查询参数，例如，你可以通过映射注解中的声明来限制传入的请求。关于这些功能的更多细节，请参见Spring MVC中<code>@RequestMapping</code>的文档。</p><p>你可以通过使用<code>ProxyExchange</code>上的<code>header()</code>方法向下游响应添加头信息。</p><p>你也可以通过给<code>get()</code>方法（和其他方法）添加一个映射器来操作响应头（以及响应中你喜欢的其他东西）。映射器是一个 &ldquo;函数&rdquo;，它接收传入的 &ldquo;ResponseEntity &ldquo;并将其转换为传出的。</p><p>对 &ldquo;敏感 &ldquo;头信息（默认情况下，<code>cookie</code>和<code>authorization</code>）提供一流的支持，这些头信息不会向下游传递，对 &ldquo;代理&rdquo;（<code>x-forwarded-*</code>）头信息也是如此。</p><h2 id=19-配置属性>19. 配置属性<a href=#19-配置属性 class=anchor aria-hidden=true>#</a></h2><p>要查看所有与Spring Cloud Gateway相关的配置属性列表，请参见<a href=https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/appendix.html>附录</a>。</p><div class=my-n3></div></main></div></div></div><footer class="footer text-muted"><div class=container><div class=row><div class="col-lg-8 order-last order-lg-first"><ul class=list-inline><li class=list-inline-item>Powered by <a href=https://www.netlify.com/>Netlify</a>, <a href=https://gohugo.io/>Hugo</a>, and <a href=https://getdoks.org/>Doks</a></li></ul></div><div class="col-lg-8 order-first order-lg-last text-lg-end"><ul class=list-inline><li class=list-inline-item><a href=https://www.springcloud.io/translation/>翻译计划</a></li><li class=list-inline-item><a href=https://www.springcloud.io/about/>关于</a></li></ul></div></div></div></footer><script src=https://www.springcloud.io/js/bootstrap.min.d67050adf5d370668aede4201f82af781b16970934804995a1ca37c1ee9222c2fc530972aa6d5d2b6124caf1fe318f139aac99df2c1e89af65504fc1185c7972.js integrity="sha512-1nBQrfXTcGaK7eQgH4KveBsWlwk0gEmVoco3we6SIsL8Uwlyqm1dK2EkyvH+MY8TmqyZ3yweia9lUE/BGFx5cg==" crossorigin=anonymous defer></script><script src=https://www.springcloud.io/js/highlight.min.21fbbff4ae23e5143eb2cab64edbdb48eb90be561eb53ee5766f2ef52ef0a1c917325706a2cdd769342b64b418c3b3030d8272769e72be6d3798fa05b0018c08.js integrity="sha512-Ifu/9K4j5RQ+ssq2TtvbSOuQvlYetT7ldm8u9S7wockXMlcGos3XaTQrZLQYw7MDDYJydp5yvm03mPoFsAGMCA==" crossorigin=anonymous defer></script><script src=https://www.springcloud.io/main.min.773144977fe359704aa8b57933ee2f435ba70c66684dfa06b01c50cf8131162bd2680301697f8d788259ff49ea7dc4d5f02683ad9ed0d53f22e99dddaeab1bab.js integrity="sha512-dzFEl3/jWXBKqLV5M+4vQ1unDGZoTfoGsBxQz4ExFivSaAMBaX+NeIJZ/0nqfcTV8CaDrZ7Q1T8i6Z3drqsbqw==" crossorigin=anonymous defer></script><script src=https://www.springcloud.io/index.min.d09e9ffa4d3486e394cd76d789c0134928c1923647b60cf55fd8aa6ba2d1d5714540654b9159091224ddc89d137d8d978b03edd7ade24d5c013536eea089b7a0.js integrity="sha512-0J6f+k00huOUzXbXicATSSjBkjZHtgz1X9iqa6LR1XFFQGVLkVkJEiTdyJ0TfY2XiwPt163iTVwBNTbuoIm3oA==" crossorigin=anonymous defer></script></body></html>